//*******************************************************************************************************
// significant portions of this file copied from: VSO\src\Vssf\WebPlatform\Platform\Scripts\VSS\WebApi\RestClient.ts
//*******************************************************************************************************
"use strict";
/// Imports of 3rd Party ///
const url = require("url");
const path = require("path");
class InvalidApiResourceVersionError {
    constructor(message) {
        this.name = "Invalid resource version";
        this.message = message;
    }
}
exports.InvalidApiResourceVersionError = InvalidApiResourceVersionError;
/**
* Base class that should be used (derived from) to make requests to VSS REST apis
*/
class VsoClient {
    constructor(baseUrl, restClient) {
        this.baseUrl = baseUrl;
        this.basePath = url.parse(baseUrl).pathname;
        this.restClient = restClient;
        this._locationsByAreaPromises = {};
        this._initializationPromise = Promise.resolve(true);
    }
    /**
    * Compares the version on the server (locationVersion) to the api version given by the client (apiVersion).
    * Returns a negative value if the location version is older (less than) the api version
    * Returns 0 if the two are equal
    * Returns a positive value if the location version is newer (greater than) the api version
    */
    compareResourceVersions(locationVersion, apiVersion) {
        // escape early if versions are the same
        if (locationVersion == apiVersion) {
            return 0;
        }
        // otherwise replaces the '-preview' flag and compares each .-separated piece of the string individually
        locationVersion = locationVersion.replace(VsoClient.PREVIEW_INDICATOR, "");
        apiVersion = apiVersion.replace(VsoClient.PREVIEW_INDICATOR, "");
        var splitLocationVersion = locationVersion.split('.');
        var splitApiVersion = apiVersion.split('.');
        var i;
        for (i = 0; i < Math.min(splitLocationVersion.length, splitApiVersion.length); i++) {
            var locationVersionPart = parseInt(splitLocationVersion[i]);
            var apiVersionPart = parseInt(splitApiVersion[i]);
            if (locationVersionPart != apiVersionPart) {
                return locationVersionPart - apiVersionPart;
            }
        }
        // if the strings aren't equal, but were the same all the way through the loop, then one version is longer (and thus newer) than the other
        return splitLocationVersion.length - splitApiVersion.length;
    }
    /**
    * Gets the route template for a resource based on its location ID and negotiates the api version
    */
    getVersioningData(apiVersion, area, locationId, routeValues, queryParams) {
        var requestUrl;
        return new Promise((resolve, reject) => {
            this.beginGetLocation(area, locationId)
                .then((location) => {
                if (!location) {
                    throw new Error("Failed to find api location for area: " + area + " id: " + locationId);
                }
                if (!apiVersion) {
                    // Use the latest version of the resource if the api version was not specified in the request.
                    apiVersion = location.maxVersion + VsoClient.PREVIEW_INDICATOR + location.resourceVersion;
                }
                else {
                    if (this.compareResourceVersions(location.minVersion, apiVersion) > 1) {
                        // Client is older than the server. The server no longer supports this resource (deprecated).
                        throw new InvalidApiResourceVersionError("The client being used is older than the server. The server no longer supports this resource (deprecated). Update the client.");
                    }
                    else if (this.compareResourceVersions(location.maxVersion, apiVersion) < 1) {
                        // Client is newer than the server. Negotiate down to the latest version on the server
                        apiVersion = location.maxVersion + VsoClient.PREVIEW_INDICATOR + location.resourceVersion;
                    }
                }
                requestUrl = this.getRequestUrl(location.routeTemplate, location.area, location.resourceName, routeValues, queryParams);
                var versionData = {
                    apiVersion: apiVersion,
                    requestUrl: requestUrl
                };
                resolve(versionData);
            }, (err) => {
                reject(err);
            });
        });
    }
    /**
     * Sets a promise that is waited on before any requests are issued. Can be used to asynchronously
     * set the request url and auth token manager.
     */
    _setInitializationPromise(promise) {
        if (promise) {
            this._initializationPromise = promise;
        }
    }
    /**
     * Gets information about an API resource location (route template, supported versions, etc.)
     *
     * @param area resource area name
     * @param locationId Guid of the location to get
     */
    beginGetLocation(area, locationId) {
        return this._initializationPromise.then(() => {
            return this.beginGetAreaLocations(area);
        }).then((areaLocations) => {
            return areaLocations[(locationId || "").toLowerCase()];
        });
    }
    beginGetAreaLocations(area) {
        var areaLocationsPromise = this._locationsByAreaPromises[area];
        if (!areaLocationsPromise) {
            areaLocationsPromise = new Promise((resolve, reject) => {
                var requestUrl = this.resolveUrl(VsoClient.APIS_RELATIVE_PATH + "/" + area);
                this._issueOptionsRequest(requestUrl, (err, statusCode, locationsResult) => {
                    if (err) {
                        err.statusCode = statusCode;
                        reject(err);
                    }
                    else {
                        var locationsLookup = {};
                        var resourceLocations = locationsResult.value;
                        var i;
                        for (i = 0; i < locationsResult.count; i++) {
                            var resourceLocation = resourceLocations[i];
                            locationsLookup[resourceLocation.id.toLowerCase()] = resourceLocation;
                        }
                        resolve(locationsLookup);
                    }
                });
            });
            this._locationsByAreaPromises[area] = areaLocationsPromise;
        }
        return areaLocationsPromise;
    }
    resolveUrl(relativeUrl) {
        return url.resolve(this.baseUrl, path.join(this.basePath, relativeUrl));
    }
    /**
    * Issues an OPTIONS request to get location objects from a location id
    */
    _issueOptionsRequest(requestUrl, onResult) {
        return this.restClient.options(requestUrl, onResult);
    }
    getSerializedObject(object) {
        let value = "";
        let first = true;
        for (var property in object) {
            if (object.hasOwnProperty(property)) {
                let prop = object[property];
                if (first && prop !== undefined) {
                    value += property + "=" + encodeURIComponent(prop);
                    first = false;
                }
                else if (prop !== undefined) {
                    value += "&" + property + "=" + encodeURIComponent(prop);
                }
            }
        }
        return value;
    }
    getRequestUrl(routeTemplate, area, resource, routeValues, queryParams) {
        // Add area/resource route values (based on the location)
        routeValues = routeValues || {};
        if (!routeValues.area) {
            routeValues.area = area;
        }
        if (!routeValues.resource) {
            routeValues.resource = resource;
        }
        // Replace templated route values
        var relativeUrl = this.replaceRouteValues(routeTemplate, routeValues);
        //append query parameters to the end
        var first = true;
        for (var queryValue in queryParams) {
            if (queryParams[queryValue] != null) {
                var value = queryParams[queryValue];
                var valueString = null;
                if (typeof (value) === 'object') {
                    valueString = this.getSerializedObject(value);
                }
                else {
                    valueString = queryValue + "=" + encodeURIComponent(queryParams[queryValue]);
                }
                if (first) {
                    relativeUrl += "?" + valueString;
                    first = false;
                }
                else {
                    relativeUrl += "&" + valueString;
                }
            }
        }
        //resolve the relative url with the base
        return url.resolve(this.baseUrl, path.join(this.basePath, relativeUrl));
    }
    /*
    * helper method copied directly from VSS\WebAPI\restclient.ts
    */
    replaceRouteValues(routeTemplate, routeValues) {
        var result = "", currentPathPart = "", paramName = "", insideParam = false, charIndex, routeTemplateLength = routeTemplate.length, c;
        for (charIndex = 0; charIndex < routeTemplateLength; charIndex++) {
            c = routeTemplate[charIndex];
            if (insideParam) {
                if (c == "}") {
                    insideParam = false;
                    if (routeValues[paramName]) {
                        currentPathPart += encodeURIComponent(routeValues[paramName]);
                    }
                    else {
                        // Normalize param name in order to capture wild-card routes
                        var strippedParamName = paramName.replace(/[^a-z0-9]/ig, '');
                        if (routeValues[strippedParamName]) {
                            currentPathPart += encodeURIComponent(routeValues[strippedParamName]);
                        }
                    }
                    paramName = "";
                }
                else {
                    paramName += c;
                }
            }
            else {
                if (c == "/") {
                    if (currentPathPart) {
                        if (result) {
                            result += "/";
                        }
                        result += currentPathPart;
                        currentPathPart = "";
                    }
                }
                else if (c == "{") {
                    if ((charIndex + 1) < routeTemplateLength && routeTemplate[charIndex + 1] == "{") {
                        // Escaped '{'
                        currentPathPart += c;
                        charIndex++;
                    }
                    else {
                        insideParam = true;
                    }
                }
                else if (c == '}') {
                    currentPathPart += c;
                    if ((charIndex + 1) < routeTemplateLength && routeTemplate[charIndex + 1] == "}") {
                        // Escaped '}'
                        charIndex++;
                    }
                }
                else {
                    currentPathPart += c;
                }
            }
        }
        if (currentPathPart) {
            if (result) {
                result += "/";
            }
            result += currentPathPart;
        }
        return result;
    }
}
VsoClient.APIS_RELATIVE_PATH = "_apis";
VsoClient.PREVIEW_INDICATOR = "-preview.";
exports.VsoClient = VsoClient;
