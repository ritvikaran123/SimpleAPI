/*
* ---------------------------------------------------------
* Copyright(C) Microsoft Corporation. All rights reserved.
* ---------------------------------------------------------
*
* ---------------------------------------------------------
* Generated file, DO NOT EDIT
* ---------------------------------------------------------
*/
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const basem = require("./ClientApiBases");
const serm = require("./Serialization");
const TaskAgentInterfaces = require("./interfaces/TaskAgentInterfaces");
class TaskApi extends basem.ClientApiBase {
    constructor(baseUrl, handlers) {
        super(baseUrl, handlers, 'node-Task-api');
    }
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {string} type
    */
    getPlanAttachments(scopeIdentifier, hubName, planId, type) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let routeValues = {
                    scopeIdentifier: scopeIdentifier,
                    hubName: hubName,
                    planId: planId,
                    type: type
                };
                try {
                    let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "distributedtask", "eb55e5d6-2f30-4295-b5ed-38da50b1fc52", routeValues);
                    let url = verData.requestUrl;
                    let apiVersion = verData.apiVersion;
                    let res = yield this.restClient.get(url, apiVersion, null);
                    let serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.TaskAttachment, responseIsCollection: true };
                    let deserializedResult = serm.ContractSerializer.serialize(res.result, serializationData, true);
                    resolve(deserializedResult);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    /**
    * @param {NodeJS.ReadableStream} contentStream - Content to upload
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {string} timelineId
    * @param {string} recordId
    * @param {string} type
    * @param {string} name
    */
    createAttachment(customHeaders, contentStream, scopeIdentifier, hubName, planId, timelineId, recordId, type, name) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let routeValues = {
                    scopeIdentifier: scopeIdentifier,
                    hubName: hubName,
                    planId: planId,
                    timelineId: timelineId,
                    recordId: recordId,
                    type: type,
                    name: name
                };
                customHeaders = customHeaders || {};
                customHeaders["Content-Type"] = "application/octet-stream";
                try {
                    let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "distributedtask", "7898f959-9cdf-4096-b29e-7f293031629e", routeValues);
                    let url = verData.requestUrl;
                    let apiVersion = verData.apiVersion;
                    let res = yield this.restClient.uploadStream('PUT', url, apiVersion, contentStream, customHeaders);
                    let serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.TaskAttachment, responseIsCollection: false };
                    let deserializedResult = serm.ContractSerializer.serialize(res.result, serializationData, true);
                    resolve(deserializedResult);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {string} timelineId
    * @param {string} recordId
    * @param {string} type
    * @param {string} name
    */
    getAttachment(scopeIdentifier, hubName, planId, timelineId, recordId, type, name) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let routeValues = {
                    scopeIdentifier: scopeIdentifier,
                    hubName: hubName,
                    planId: planId,
                    timelineId: timelineId,
                    recordId: recordId,
                    type: type,
                    name: name
                };
                try {
                    let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "distributedtask", "7898f959-9cdf-4096-b29e-7f293031629e", routeValues);
                    let url = verData.requestUrl;
                    let apiVersion = verData.apiVersion;
                    let res = yield this.restClient.get(url, apiVersion, null);
                    let serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.TaskAttachment, responseIsCollection: false };
                    let deserializedResult = serm.ContractSerializer.serialize(res.result, serializationData, true);
                    resolve(deserializedResult);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {string} timelineId
    * @param {string} recordId
    * @param {string} type
    * @param {string} name
    */
    getAttachmentContent(scopeIdentifier, hubName, planId, timelineId, recordId, type, name) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let onResult = (err, statusCode, attachment) => {
                    if (err) {
                        err.statusCode = statusCode;
                        reject(err);
                    }
                    else {
                        resolve(attachment);
                    }
                };
                let routeValues = {
                    scopeIdentifier: scopeIdentifier,
                    hubName: hubName,
                    planId: planId,
                    timelineId: timelineId,
                    recordId: recordId,
                    type: type,
                    name: name
                };
                try {
                    let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "distributedtask", "7898f959-9cdf-4096-b29e-7f293031629e", routeValues);
                    let url = verData.requestUrl;
                    let apiVersion = verData.apiVersion;
                    let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
                    this.httpClient.getStream(url, accept, onResult);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {string} timelineId
    * @param {string} recordId
    * @param {string} type
    */
    getAttachments(scopeIdentifier, hubName, planId, timelineId, recordId, type) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let routeValues = {
                    scopeIdentifier: scopeIdentifier,
                    hubName: hubName,
                    planId: planId,
                    timelineId: timelineId,
                    recordId: recordId,
                    type: type
                };
                try {
                    let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "distributedtask", "7898f959-9cdf-4096-b29e-7f293031629e", routeValues);
                    let url = verData.requestUrl;
                    let apiVersion = verData.apiVersion;
                    let res = yield this.restClient.get(url, apiVersion, null);
                    let serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.TaskAttachment, responseIsCollection: true };
                    let deserializedResult = serm.ContractSerializer.serialize(res.result, serializationData, true);
                    resolve(deserializedResult);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    /**
    * @param {VSSInterfaces.VssJsonCollectionWrapperV<string[]>} lines
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {string} timelineId
    * @param {string} recordId
    */
    appendTimelineRecordFeed(lines, scopeIdentifier, hubName, planId, timelineId, recordId) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let routeValues = {
                    scopeIdentifier: scopeIdentifier,
                    hubName: hubName,
                    planId: planId,
                    timelineId: timelineId,
                    recordId: recordId
                };
                try {
                    let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "distributedtask", "858983e4-19bd-4c5e-864c-507b59b58b12", routeValues);
                    let url = verData.requestUrl;
                    let apiVersion = verData.apiVersion;
                    let res = yield this.restClient.create(url, apiVersion, lines, null);
                    let serializationData = { responseIsCollection: false };
                    let deserializedResult = serm.ContractSerializer.serialize(res.result, serializationData, true);
                    resolve(null);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    /**
    * @param {NodeJS.ReadableStream} contentStream - Content to upload
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {number} logId
    */
    appendLogContent(customHeaders, contentStream, scopeIdentifier, hubName, planId, logId) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let routeValues = {
                    scopeIdentifier: scopeIdentifier,
                    hubName: hubName,
                    planId: planId,
                    logId: logId
                };
                customHeaders = customHeaders || {};
                customHeaders["Content-Type"] = "application/octet-stream";
                try {
                    let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "distributedtask", "46f5667d-263a-4684-91b1-dff7fdcf64e2", routeValues);
                    let url = verData.requestUrl;
                    let apiVersion = verData.apiVersion;
                    let res = yield this.restClient.uploadStream('POST', url, apiVersion, contentStream, customHeaders);
                    let serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.TaskLog, responseIsCollection: false };
                    let deserializedResult = serm.ContractSerializer.serialize(res.result, serializationData, true);
                    resolve(deserializedResult);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    /**
    * @param {TaskAgentInterfaces.TaskLog} log
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    */
    createLog(log, scopeIdentifier, hubName, planId) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let routeValues = {
                    scopeIdentifier: scopeIdentifier,
                    hubName: hubName,
                    planId: planId
                };
                try {
                    let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "distributedtask", "46f5667d-263a-4684-91b1-dff7fdcf64e2", routeValues);
                    let url = verData.requestUrl;
                    let apiVersion = verData.apiVersion;
                    let res = yield this.restClient.create(url, apiVersion, log, null);
                    let serializationData = { requestTypeMetadata: TaskAgentInterfaces.TypeInfo.TaskLog, responseTypeMetadata: TaskAgentInterfaces.TypeInfo.TaskLog, responseIsCollection: false };
                    let deserializedResult = serm.ContractSerializer.serialize(res.result, serializationData, true);
                    resolve(deserializedResult);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {number} logId
    * @param {number} startLine
    * @param {number} endLine
    */
    getLog(scopeIdentifier, hubName, planId, logId, startLine, endLine) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let routeValues = {
                    scopeIdentifier: scopeIdentifier,
                    hubName: hubName,
                    planId: planId,
                    logId: logId
                };
                let queryValues = {
                    startLine: startLine,
                    endLine: endLine,
                };
                try {
                    let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "distributedtask", "46f5667d-263a-4684-91b1-dff7fdcf64e2", routeValues, queryValues);
                    let url = verData.requestUrl;
                    let apiVersion = verData.apiVersion;
                    let res = yield this.restClient.get(url, apiVersion, null);
                    let serializationData = { responseIsCollection: true };
                    let deserializedResult = serm.ContractSerializer.serialize(res.result, serializationData, true);
                    resolve(deserializedResult);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    */
    getLogs(scopeIdentifier, hubName, planId) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let routeValues = {
                    scopeIdentifier: scopeIdentifier,
                    hubName: hubName,
                    planId: planId
                };
                try {
                    let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "distributedtask", "46f5667d-263a-4684-91b1-dff7fdcf64e2", routeValues);
                    let url = verData.requestUrl;
                    let apiVersion = verData.apiVersion;
                    let res = yield this.restClient.get(url, apiVersion, null);
                    let serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.TaskLog, responseIsCollection: true };
                    let deserializedResult = serm.ContractSerializer.serialize(res.result, serializationData, true);
                    resolve(deserializedResult);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    */
    getPlan(scopeIdentifier, hubName, planId) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let routeValues = {
                    scopeIdentifier: scopeIdentifier,
                    hubName: hubName,
                    planId: planId
                };
                try {
                    let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "distributedtask", "5cecd946-d704-471e-a45f-3b4064fcfaba", routeValues);
                    let url = verData.requestUrl;
                    let apiVersion = verData.apiVersion;
                    let res = yield this.restClient.get(url, apiVersion, null);
                    let serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.TaskOrchestrationPlan, responseIsCollection: false };
                    let deserializedResult = serm.ContractSerializer.serialize(res.result, serializationData, true);
                    resolve(deserializedResult);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {string} timelineId
    * @param {number} changeId
    */
    getRecords(scopeIdentifier, hubName, planId, timelineId, changeId) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let routeValues = {
                    scopeIdentifier: scopeIdentifier,
                    hubName: hubName,
                    planId: planId,
                    timelineId: timelineId
                };
                let queryValues = {
                    changeId: changeId,
                };
                try {
                    let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "distributedtask", "8893bc5b-35b2-4be7-83cb-99e683551db4", routeValues, queryValues);
                    let url = verData.requestUrl;
                    let apiVersion = verData.apiVersion;
                    let res = yield this.restClient.get(url, apiVersion, null);
                    let serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.TimelineRecord, responseIsCollection: true };
                    let deserializedResult = serm.ContractSerializer.serialize(res.result, serializationData, true);
                    resolve(deserializedResult);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    /**
    * @param {VSSInterfaces.VssJsonCollectionWrapperV<TaskAgentInterfaces.TimelineRecord[]>} records
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {string} timelineId
    */
    updateRecords(records, scopeIdentifier, hubName, planId, timelineId) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let routeValues = {
                    scopeIdentifier: scopeIdentifier,
                    hubName: hubName,
                    planId: planId,
                    timelineId: timelineId
                };
                try {
                    let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "distributedtask", "8893bc5b-35b2-4be7-83cb-99e683551db4", routeValues);
                    let url = verData.requestUrl;
                    let apiVersion = verData.apiVersion;
                    let res = yield this.restClient.update(url, apiVersion, records, null);
                    let serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.TimelineRecord, responseIsCollection: true };
                    let deserializedResult = serm.ContractSerializer.serialize(res.result, serializationData, true);
                    resolve(deserializedResult);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    /**
    * @param {TaskAgentInterfaces.Timeline} timeline
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    */
    createTimeline(timeline, scopeIdentifier, hubName, planId) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let routeValues = {
                    scopeIdentifier: scopeIdentifier,
                    hubName: hubName,
                    planId: planId
                };
                try {
                    let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "distributedtask", "83597576-cc2c-453c-bea6-2882ae6a1653", routeValues);
                    let url = verData.requestUrl;
                    let apiVersion = verData.apiVersion;
                    let res = yield this.restClient.create(url, apiVersion, timeline, null);
                    let serializationData = { requestTypeMetadata: TaskAgentInterfaces.TypeInfo.Timeline, responseTypeMetadata: TaskAgentInterfaces.TypeInfo.Timeline, responseIsCollection: false };
                    let deserializedResult = serm.ContractSerializer.serialize(res.result, serializationData, true);
                    resolve(deserializedResult);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {string} timelineId
    */
    deleteTimeline(scopeIdentifier, hubName, planId, timelineId) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let routeValues = {
                    scopeIdentifier: scopeIdentifier,
                    hubName: hubName,
                    planId: planId,
                    timelineId: timelineId
                };
                try {
                    let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "distributedtask", "83597576-cc2c-453c-bea6-2882ae6a1653", routeValues);
                    let url = verData.requestUrl;
                    let apiVersion = verData.apiVersion;
                    let res = yield this.restClient.del(url, apiVersion, null);
                    let serializationData = { responseIsCollection: false };
                    let deserializedResult = serm.ContractSerializer.serialize(res.result, serializationData, true);
                    resolve(null);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    * @param {string} timelineId
    * @param {number} changeId
    * @param {boolean} includeRecords
    */
    getTimeline(scopeIdentifier, hubName, planId, timelineId, changeId, includeRecords) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let routeValues = {
                    scopeIdentifier: scopeIdentifier,
                    hubName: hubName,
                    planId: planId,
                    timelineId: timelineId
                };
                let queryValues = {
                    changeId: changeId,
                    includeRecords: includeRecords,
                };
                try {
                    let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "distributedtask", "83597576-cc2c-453c-bea6-2882ae6a1653", routeValues, queryValues);
                    let url = verData.requestUrl;
                    let apiVersion = verData.apiVersion;
                    let res = yield this.restClient.get(url, apiVersion, null);
                    let serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.Timeline, responseIsCollection: false };
                    let deserializedResult = serm.ContractSerializer.serialize(res.result, serializationData, true);
                    resolve(deserializedResult);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    /**
    * @param {string} scopeIdentifier - The project GUID to scope the request
    * @param {string} hubName - The name of the server hub: "build" for the Build server or "rm" for the Release Management server
    * @param {string} planId
    */
    getTimelines(scopeIdentifier, hubName, planId) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let routeValues = {
                    scopeIdentifier: scopeIdentifier,
                    hubName: hubName,
                    planId: planId
                };
                try {
                    let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "distributedtask", "83597576-cc2c-453c-bea6-2882ae6a1653", routeValues);
                    let url = verData.requestUrl;
                    let apiVersion = verData.apiVersion;
                    let res = yield this.restClient.get(url, apiVersion, null);
                    let serializationData = { responseTypeMetadata: TaskAgentInterfaces.TypeInfo.Timeline, responseIsCollection: true };
                    let deserializedResult = serm.ContractSerializer.serialize(res.result, serializationData, true);
                    resolve(deserializedResult);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
}
exports.TaskApi = TaskApi;
