"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NuGetConfigHelper2 = void 0;
const fs = require("fs");
const path = require("path");
const url = require("url");
const tl = require("azure-pipelines-task-lib/task");
const auth = require("./Authentication");
const NuGetExeXmlHelper_1 = require("./NuGetExeXmlHelper");
const NuGetXmlHelper_1 = require("./NuGetXmlHelper");
const ngutil = require("./Utility");
// NuGetConfigHelper2 handles authenticated scenarios where the user selects a source from the UI or from a service connection.
// It is used by the NuGetCommand >= v2.0.0 and DotNetCoreCLI >= v2.0.0
const nugetFileName = 'nuget.config';
class NuGetConfigHelper2 {
    constructor(nugetPath, nugetConfigPath, authInfo, environmentSettings, tempConfigPath /*optional*/, useNuGetToModifyConfigFile /* optional */) {
        this.nugetPath = nugetPath;
        this.nugetConfigPath = nugetConfigPath;
        this.authInfo = authInfo;
        this.environmentSettings = environmentSettings;
        this.tempNugetConfigPath = undefined;
        this.tempNugetConfigPath = tempConfigPath || this.getTempNuGetConfigPath();
        useNuGetToModifyConfigFile = useNuGetToModifyConfigFile === undefined ? true : useNuGetToModifyConfigFile;
        this.nugetXmlHelper = useNuGetToModifyConfigFile ?
            new NuGetExeXmlHelper_1.NuGetExeXmlHelper(this.nugetPath, this.tempNugetConfigPath, this.authInfo, this.environmentSettings) :
            new NuGetXmlHelper_1.NuGetXmlHelper(this.tempNugetConfigPath);
    }
    static getTempNuGetConfigBasePath() {
        return tl.getVariable("Agent.BuildDirectory")
            || tl.getVariable("Agent.TempDirectory");
    }
    ensureTempConfigCreated() {
        // save nuget config file to agent build directory
        tl.debug(tl.loc("Info_SavingTempConfig"));
        let tempNuGetConfigDir = path.dirname(this.tempNugetConfigPath);
        if (!tl.exist(tempNuGetConfigDir)) {
            tl.mkdirP(tempNuGetConfigDir);
        }
        if (!tl.exist(this.tempNugetConfigPath)) {
            if (this.nugetConfigPath) {
                // don't use cp as that copies the read-only flag, and tfvc sets that on files
                let content = fs.readFileSync(this.nugetConfigPath);
                tl.writeFile(this.tempNugetConfigPath, content);
            }
            else {
                // small file, use writeFileSync
                tl.writeFile(this.tempNugetConfigPath, "<configuration/>");
            }
        }
    }
    addSourcesToTempNuGetConfig(packageSources) {
        tl.debug('Adding sources to nuget.config');
        this.ensureTempConfigCreated();
        this.addSourcesToTempNugetConfigInternal(packageSources);
    }
    setAuthForSourcesInTempNuGetConfig() {
        tl.debug('Setting auth in the temp nuget.config');
        this.ensureTempConfigCreated();
        let sources = this.getSourcesFromTempNuGetConfig();
        if (sources.length < 1) {
            tl.debug('Not setting up auth for temp nuget.config as there are no sources');
            return;
        }
        sources.forEach((source) => {
            tl.debug(`considering source ${source.feedUri}. Internal: ${source.isInternal}`);
            if (source.isInternal) {
                if (this.authInfo.internalAuthInfo.useCredConfig) {
                    tl.debug('Setting auth for internal source ' + source.feedUri);
                    // Removing source first
                    this.removeSourceFromTempNugetConfig(source);
                    // Cannot add tag that starts with number as a child node of PackageSourceCredentials because of
                    // Bug in nuget 4.9.1 and dotnet 2.1.500
                    // https://github.com/NuGet/Home/issues/7517
                    // https://github.com/NuGet/Home/issues/7524
                    // so working around this by prefixing source with string
                    tl.debug('Prefixing internal source feed name ' + source.feedName + ' with feed-');
                    source.feedName = 'feed-' + source.feedName;
                    // Re-adding source with creds
                    this.addSourceWithUsernamePasswordToTempNuGetConfig(source, "VssSessionToken", this.authInfo.internalAuthInfo.accessToken);
                }
            }
            // Source is external
            else {
                if (!this.authInfo.externalAuthInfo || this.authInfo.externalAuthInfo.length < 1) {
                    tl.debug('No external auth information');
                    return;
                }
                let indexAuthInfo = this.authInfo.externalAuthInfo.findIndex(externalEndpoint => url.parse(externalEndpoint.packageSource.feedUri).href.toLowerCase() === url.parse(source.feedUri).href.toLowerCase());
                if (indexAuthInfo > -1) {
                    let externalEndpointAuthInfo = this.authInfo.externalAuthInfo[indexAuthInfo];
                    tl.debug('Setting auth for external source ' + source.feedUri);
                    console.log(tl.loc("Info_MatchingUrlWasFoundSettingAuth") + source.feedUri);
                    switch (externalEndpointAuthInfo.authType) {
                        case (auth.ExternalAuthType.UsernamePassword):
                            let usernamePwdAuthInfo = externalEndpointAuthInfo;
                            this.removeSourceFromTempNugetConfig(source);
                            this.addSourceWithUsernamePasswordToTempNuGetConfig(source, usernamePwdAuthInfo.username, usernamePwdAuthInfo.password);
                            break;
                        case (auth.ExternalAuthType.Token):
                            let tokenAuthInfo = externalEndpointAuthInfo;
                            this.removeSourceFromTempNugetConfig(source);
                            this.addSourceWithUsernamePasswordToTempNuGetConfig(source, "CustomToken", tokenAuthInfo.token);
                            break;
                        case (auth.ExternalAuthType.ApiKey):
                            let apiKeyAuthInfo = externalEndpointAuthInfo;
                            this.setApiKeyForSourceInTempNuGetConfig(source, apiKeyAuthInfo.apiKey);
                            break;
                        default:
                            break;
                    }
                }
                else {
                    tl.debug(`No auth information found for source ${source.feedUri}`);
                }
            }
        });
    }
    getTempNuGetConfigPath() {
        const tempNuGetConfigBaseDir = NuGetConfigHelper2.getTempNuGetConfigBasePath();
        const tempNuGetConfigFileName = "tempNuGet_" + tl.getVariable("build.buildId") + ".config";
        return path.join(tempNuGetConfigBaseDir, "Nuget", tempNuGetConfigFileName);
    }
    getSourcesFromTempNuGetConfig() {
        // load content of the user's nuget.config
        let configPath = this.tempNugetConfigPath ? this.tempNugetConfigPath : this.nugetConfigPath;
        if (!configPath) {
            return [];
        }
        let packageSources = ngutil.getSourcesFromNuGetConfig(configPath);
        return packageSources.map((source) => this.convertToIPackageSource(source));
    }
    // TODO: Remove these two methods once NuGet issue https://github.com/NuGet/Home/issues/7855 is fixed.
    backupExistingRootNuGetFiles() {
        this.rootNuGetFiles = fs.readdirSync('.').filter((file) => file.toLowerCase() === nugetFileName);
        if (this.shouldWriteRootNuGetFiles()) {
            this.rootNuGetFiles.forEach((file) => fs.renameSync(file, this.temporaryRootNuGetName(file)));
            fs.writeFileSync(nugetFileName, fs.readFileSync(this.tempNugetConfigPath));
        }
    }
    restoreBackupRootNuGetFiles() {
        if (this.shouldWriteRootNuGetFiles()) {
            fs.unlinkSync(nugetFileName);
            this.rootNuGetFiles.forEach((file) => fs.renameSync(this.temporaryRootNuGetName(file), file));
        }
    }
    removeSourceFromTempNugetConfig(packageSource) {
        this.nugetXmlHelper.RemoveSourceFromNuGetConfig(packageSource.feedName);
    }
    addSourcesToTempNugetConfigInternal(packageSources) {
        packageSources.forEach((source) => {
            this.nugetXmlHelper.AddSourceToNuGetConfig(source.feedName, source.feedUri);
        });
    }
    addSourceWithUsernamePasswordToTempNuGetConfig(source, username, password) {
        this.nugetXmlHelper.AddSourceToNuGetConfig(source.feedName, source.feedUri, username, password);
    }
    setApiKeyForSourceInTempNuGetConfig(source, apiKey) {
        this.nugetXmlHelper.SetApiKeyInNuGetConfig(source.feedName, apiKey);
    }
    convertToIPackageSource(source) {
        const uppercaseUri = source.feedUri.toUpperCase();
        const isInternal = this.authInfo.internalAuthInfo ? this.authInfo.internalAuthInfo.uriPrefixes.some(prefix => uppercaseUri.indexOf(prefix.toUpperCase()) === 0) : false;
        return {
            feedName: source.feedName,
            feedUri: source.feedUri,
            isInternal
        };
    }
    // TODO: Remove these two methods once NuGet issue https://github.com/NuGet/Home/issues/7855 is fixed.
    temporaryRootNuGetName(nugetFile) {
        return `tempRename_${tl.getVariable('build.buildId')}_${nugetFile}`;
    }
    shouldWriteRootNuGetFiles() {
        return (this.nugetConfigPath != null && path.relative('.', this.nugetConfigPath).toLocaleLowerCase() == nugetFileName) || this.rootNuGetFiles.length == 0;
    }
}
exports.NuGetConfigHelper2 = NuGetConfigHelper2;
