"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PEImageFile = void 0;
const PEParserError_1 = require("./PEParserError");
const SectionTable_1 = require("./SectionTable");
const dosSignature = 0x5A4D;
const fileOffsetOfPointerToPESignature = 0x3C;
const peSignature = 0x00004550;
const sizeOfCoffHeader = 20;
class PEImageFile {
    constructor(coffHeader, sectionTable) {
        this.coffHeader = coffHeader;
        this.sectionTable = sectionTable;
    }
    static readAsync(file) {
        return __awaiter(this, void 0, void 0, function* () {
            let buffer = new Buffer(1024);
            buffer.fill(0);
            // read the DOS signature
            yield file.readAsync(buffer, 0, 2, 0);
            const dosSignatureValue = buffer.readUInt16LE(0);
            if (dosSignatureValue !== dosSignature) {
                throw new PEParserError_1.default("invalidSignature", "The DOS signature of the PE file does not match the expected value");
            }
            // read the pointer to the PE signature
            yield file.readAsync(buffer, 0, 4, fileOffsetOfPointerToPESignature);
            const filePositionOfPEHeader = buffer.readUInt32LE(0);
            // read the PE signature
            yield file.readAsync(buffer, 0, 4, filePositionOfPEHeader);
            const peSignatureValue = buffer.readUInt32LE(0);
            if (peSignatureValue !== peSignature) {
                throw new PEParserError_1.default("invalidSignature", "The PE signature of the PE file does not match the expected value");
            }
            // the COFF header begins immediately after the PE signature
            const filePositionOfCoffHeader = filePositionOfPEHeader + 4;
            yield file.readAsync(buffer, 0, sizeOfCoffHeader, filePositionOfCoffHeader);
            const coffHeader = {
                machine: buffer.readUInt16LE(0),
                numberOfSections: buffer.readUInt16LE(2),
                timeDateStamp: buffer.readUInt32LE(4),
                pointerToSymbolTable: buffer.readUInt32LE(8),
                numberOfSymbols: buffer.readUInt32LE(12),
                sizeOfOptionalHeader: buffer.readUInt16LE(16),
                characteristics: buffer.readUInt16LE(18),
            };
            // the Optional Header begins immediately after the COFF header
            const filePositionOfOptionalHeader = filePositionOfCoffHeader + sizeOfCoffHeader;
            // the section table begins immediately after the Optional Header
            const filePositionOfSectionTable = filePositionOfOptionalHeader + coffHeader.sizeOfOptionalHeader;
            let sectionTable = yield SectionTable_1.SectionTable.readAsync(file, buffer, filePositionOfSectionTable, coffHeader.numberOfSections);
            return new PEImageFile(coffHeader, sectionTable);
        });
    }
    getSection(name) {
        return this.sectionTable.getSection(name);
    }
}
exports.PEImageFile = PEImageFile;
exports.default = PEImageFile;
