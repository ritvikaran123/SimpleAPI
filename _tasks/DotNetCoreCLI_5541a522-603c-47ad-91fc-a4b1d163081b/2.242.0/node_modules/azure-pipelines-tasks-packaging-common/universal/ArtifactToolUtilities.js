"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHighestPackageVersionFromFeed = exports.getPackageNameFromId = exports.getVersionUtility = exports.getArtifactToolFromService = exports.extractZip = exports.getArtifactToolLocation = void 0;
// Placed as a separate file for the purpose of unit testing
// TODO: Update functions in this file to call the implementations in ClientToolUtilities.ts
const AdmZip = require("adm-zip");
const os = require("os");
const path = require("path");
const semver = require("semver");
const pkgLocationUtils = require("../locationUtilities");
const tl = require("azure-pipelines-task-lib");
const toollib = require("azure-pipelines-tool-lib/tool");
function getArtifactToolLocation(dirName) {
    let toolPath = path.join(dirName, "ArtifactTool.exe");
    if (tl.osType() !== "Windows_NT") {
        toolPath = path.join(dirName, "artifacttool");
    }
    return toolPath;
}
exports.getArtifactToolLocation = getArtifactToolLocation;
function _createExtractFolder(dest) {
    if (!dest) {
        // create a temp dir
        dest = path.join(tl.getVariable("Agent.TempDirectory"), "artifactTool");
    }
    tl.mkdirP(dest);
    return dest;
}
// there is a reason we do this instead of toollib.extractZip, but we don't recall what it is
// (might be Mac compatibility)
function extractZip(file) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!file) {
            throw new Error("parameter 'file' is required");
        }
        let dest = _createExtractFolder();
        let zip = new AdmZip(file);
        zip.extractAllTo(dest, true);
        return dest;
    });
}
exports.extractZip = extractZip;
function getArtifactToolFromService(serviceUri, accessToken, toolName) {
    return __awaiter(this, void 0, void 0, function* () {
        const overrideArtifactToolPath = tl.getVariable("UPack.OverrideArtifactToolPath");
        if (overrideArtifactToolPath != null) {
            return getArtifactToolLocation(overrideArtifactToolPath);
        }
        let osName = tl.osType();
        let arch = os.arch();
        if (osName === "Windows_NT") {
            osName = "windows";
        }
        if (arch === "x64") {
            arch = "amd64";
        }
        // https://github.com/nodejs/node-v0.x-archive/issues/2862
        if (arch === "ia32") {
            if (process.env.PROCESSOR_ARCHITEW6432 != null && process.env.PROCESSOR_ARCHITEW6432.toUpperCase() === "AMD64") {
                arch = "amd64";
            }
        }
        if (arch.toLowerCase() !== "amd64") {
            throw new Error(tl.loc("Error_ProcessorArchitectureNotSupported"));
        }
        const blobstoreAreaName = "clienttools";
        const blobstoreAreaId = "187ec90d-dd1e-4ec6-8c57-937d979261e5";
        const ApiVersion = "5.0-preview";
        const blobstoreConnection = pkgLocationUtils.getWebApiWithProxy(serviceUri, accessToken);
        const artifactToolGetUrl = yield blobstoreConnection.vsoClient.getVersioningData(ApiVersion, blobstoreAreaName, blobstoreAreaId, { toolName }, { osName, arch });
        const artifactToolUri = yield blobstoreConnection.rest.get(artifactToolGetUrl.requestUrl);
        if (artifactToolUri.statusCode !== 200) {
            tl.debug(tl.loc("Error_UnexpectedErrorFailedToGetToolMetadata", artifactToolUri.result.toString()));
            throw new Error(tl.loc("Error_UnexpectedErrorFailedToGetToolMetadata", artifactToolGetUrl.requestUrl));
        }
        let artifactToolPath = toollib.findLocalTool(toolName, artifactToolUri.result['version']);
        if (!artifactToolPath) {
            tl.debug(tl.loc("Info_DownloadingArtifactTool", artifactToolUri.result['uri']));
            const zippedToolsDir = yield pkgLocationUtils.retryOnExceptionHelper(() => toollib.downloadTool(artifactToolUri.result['uri']), 3, 1000);
            tl.debug("Downloaded zipped artifact tool to " + zippedToolsDir);
            const unzippedToolsDir = yield extractZip(zippedToolsDir);
            artifactToolPath = yield toollib.cacheDir(unzippedToolsDir, "ArtifactTool", artifactToolUri.result['version']);
        }
        else {
            tl.debug(tl.loc("Info_ResolvedToolFromCache", artifactToolPath));
        }
        return getArtifactToolLocation(artifactToolPath);
    });
}
exports.getArtifactToolFromService = getArtifactToolFromService;
function getVersionUtility(versionRadio, highestVersion) {
    switch (versionRadio) {
        case "patch":
            return semver.inc(highestVersion, "patch");
        case "minor":
            return semver.inc(highestVersion, "minor");
        case "major":
            return semver.inc(highestVersion, "major");
        default:
            return null;
    }
}
exports.getVersionUtility = getVersionUtility;
function getPackageNameFromId(serviceUri, accessToken, projectId, feedId, packageId) {
    return __awaiter(this, void 0, void 0, function* () {
        const ApiVersion = "3.0-preview.1";
        const PackagingAreaName = "Packaging";
        const PackageAreaId = "7a20d846-c929-4acc-9ea2-0d5a7df1b197";
        const feedConnection = pkgLocationUtils.getWebApiWithProxy(serviceUri, accessToken);
        let routeValues = { feedId: feedId, packageId: packageId, project: projectId };
        if (!projectId) {
            delete routeValues.project;
        }
        // Getting url for feeds version API
        const packageUrl = yield new Promise((resolve, reject) => {
            let getVersioningDataPromise = feedConnection.vsoClient.getVersioningData(ApiVersion, PackagingAreaName, PackageAreaId, routeValues);
            getVersioningDataPromise.then((result) => {
                return resolve(result.requestUrl);
            });
            getVersioningDataPromise.catch((error) => {
                return reject(error);
            });
        });
        // Return the user input incase of failure
        try {
            const response = yield feedConnection.rest.get(packageUrl);
            if (response.statusCode === 200 && response.result['name']) {
                return response.result['name'];
            }
            return packageId;
        }
        catch (err) {
            return packageId;
        }
    });
}
exports.getPackageNameFromId = getPackageNameFromId;
/**
 * Returns the highest package version from a Feed for a given package. If no versions for this package name exist, we will return highest version of 0.0.0
 */
function getHighestPackageVersionFromFeed(serviceUri, accessToken, projectId, feedId, packageName) {
    return __awaiter(this, void 0, void 0, function* () {
        const ApiVersion = "3.0-preview.1";
        const PackagingAreaName = "Packaging";
        const PackageAreaId = "7a20d846-c929-4acc-9ea2-0d5a7df1b197";
        const feedConnection = pkgLocationUtils.getWebApiWithProxy(serviceUri, accessToken);
        let routeValues = { feedId: feedId, project: projectId };
        if (!projectId) {
            delete routeValues.project;
        }
        // Getting url for feeds version API
        const data = yield feedConnection.vsoClient.getVersioningData(ApiVersion, PackagingAreaName, PackageAreaId, routeValues, { packageNameQuery: packageName, protocolType: "upack", includeDeleted: "true", includeUrls: "false" });
        tl.debug(tl.loc("Info_ResolvePackageVersionRoute", data.requestUrl));
        const result = yield feedConnection.rest.get(data.requestUrl);
        if (result.result != null) {
            if (!result.result['count']) {
                return "0.0.0";
            }
            else {
                for (var element of result.result['value']) {
                    if (element.name === packageName.toLowerCase()) {
                        return element.versions[0].version;
                    }
                }
                ;
            }
        }
        return "0.0.0";
    });
}
exports.getHighestPackageVersionFromFeed = getHighestPackageVersionFromFeed;
