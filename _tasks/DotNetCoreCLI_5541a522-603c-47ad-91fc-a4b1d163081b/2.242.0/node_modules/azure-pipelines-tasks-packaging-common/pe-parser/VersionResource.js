"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VersionResource = void 0;
const PEParserError_1 = require("./PEParserError");
const VersionInfoVersion_1 = require("./VersionInfoVersion");
const neutralLanguageUnicodeCodePage = "000004b0";
function readNullTerminatedUcs2String(buffer, offset) {
    let end = offset;
    while (end < buffer.length - 1) {
        if (buffer.readInt16LE(end) === 0) {
            return { value: buffer.toString("utf16le", offset, end), bytesRead: end - offset + 2 };
        }
        end += 2;
    }
    throw new PEParserError_1.default("unterminatedString", "Unterminated string");
}
function roundUp(value, multiple) {
    const remainder = value % multiple;
    return remainder === 0 ? value : value + multiple - remainder;
}
function readRawVsVersionInfoElementHeader(buffer, offset) {
    let fixedPartLength = 6;
    let length = buffer.readUInt16LE(offset + 0);
    let key = readNullTerminatedUcs2String(buffer, offset + fixedPartLength);
    let valueOffset = roundUp(offset + fixedPartLength + key.bytesRead, 4);
    let type = buffer.readUInt16LE(offset + 4);
    let valueLength = buffer.readUInt16LE(offset + 2);
    if (type === 1) {
        valueLength *= 2;
    }
    let childrenOffset = roundUp(valueOffset + valueLength, 4);
    return {
        length,
        valueLength,
        type,
        key: key.value,
        offset,
        valueOffset,
        childrenOffset,
    };
}
function readRawVsFixedFileInfo(buffer, offset) {
    return {
        signature: buffer.readUInt32LE(offset + 0),
        structVersion: buffer.readUInt32LE(offset + 4),
        fileVersionMS: buffer.readUInt32LE(offset + 8),
        fileVersionLS: buffer.readUInt32LE(offset + 12),
        productVersionMS: buffer.readUInt32LE(offset + 16),
        productVersionLS: buffer.readUInt32LE(offset + 20),
        fileFlagsMask: buffer.readUInt32LE(offset + 24),
        fileFlags: buffer.readUInt32LE(offset + 28),
        fileOS: buffer.readUInt32LE(offset + 32),
        fileType: buffer.readUInt32LE(offset + 36),
        fileSubtype: buffer.readUInt32LE(offset + 40),
        fileDateMS: buffer.readUInt32LE(offset + 44),
        fileDateLS: buffer.readUInt32LE(offset + 48),
    };
}
function readRawVsVersionInfoTree(buffer, offset, depth) {
    if (depth === undefined) {
        depth = 0;
    }
    let thisElement = {
        header: readRawVsVersionInfoElementHeader(buffer, offset),
        rawChildren: [],
    };
    let childOffset = thisElement.header.childrenOffset;
    while (childOffset < offset + thisElement.header.length) {
        let child = readRawVsVersionInfoTree(buffer, childOffset, depth + 1);
        thisElement.rawChildren.push(child);
        childOffset = roundUp(childOffset + child.header.length, 4);
    }
    return thisElement;
}
function processVersionInfoFromTree(root, buffer) {
    let result = { strings: {} };
    // root should be VS_VERSION_INFO
    if (root.header.key !== "VS_VERSION_INFO") {
        throw "Not a valid version resource";
    }
    if (root.header.valueLength !== 0) {
        let fixedFileInfo = readRawVsFixedFileInfo(buffer, root.header.valueOffset);
        result.fileVersion = VersionInfoVersion_1.default.fromDWords(fixedFileInfo.fileVersionMS, fixedFileInfo.fileVersionLS);
        result.productVersion = VersionInfoVersion_1.default.fromDWords(fixedFileInfo.productVersionMS, fixedFileInfo.productVersionLS);
    }
    let stringFileInfoElement = root.rawChildren.find(x => x.header.key === "StringFileInfo");
    if (stringFileInfoElement) {
        let languageNeutralUnicodeStringTableElement = stringFileInfoElement.rawChildren.find(x => x.header.key === neutralLanguageUnicodeCodePage);
        if (languageNeutralUnicodeStringTableElement) {
            for (let versionString of languageNeutralUnicodeStringTableElement.rawChildren) {
                result.strings[versionString.header.key] = readNullTerminatedUcs2String(buffer, versionString.header.valueOffset).value;
            }
        }
    }
    return result;
}
class VersionResource {
    constructor(buffer) {
        this.rawVersionInfoTree = readRawVsVersionInfoTree(buffer, 0);
        this.versionInfo = processVersionInfoFromTree(this.rawVersionInfoTree, buffer);
    }
}
exports.VersionResource = VersionResource;
exports.default = VersionResource;
