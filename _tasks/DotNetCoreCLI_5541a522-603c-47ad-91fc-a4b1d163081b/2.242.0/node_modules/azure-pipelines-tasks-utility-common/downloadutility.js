"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.download = void 0;
var https = require('https');
var fs = require('fs');
var url = require('url');
const tl = require("azure-pipelines-task-lib/task");
function isDownloadSucceeded(response) {
    return response.statusCode >= 200 && response.statusCode < 300;
}
function isRedirect(response) {
    return response.statusCode >= 300
        && response.statusCode < 400
        && response.headers
        && response.headers.location;
}
function getRedirectOptions(options, redirectUrl) {
    tl.debug("redirect url: " + redirectUrl);
    if (typeof options === 'string') {
        options = redirectUrl;
    }
    else {
        try {
            var redirectUrlOptions = url.parse(redirectUrl);
            options.path = redirectUrlOptions.path;
            options.hostname = redirectUrlOptions.hostname;
        }
        catch (error) {
            tl.warning("Unable to parse url:" + redirectUrl);
            options = redirectUrl;
        }
    }
    return options;
}
function download(options, downloadPath, printData, handleRedirect) {
    return __awaiter(this, void 0, void 0, function* () {
        var file = fs.createWriteStream(downloadPath);
        var body = '';
        return new Promise((resolve, reject) => {
            var req = https.request(options, res => {
                tl.debug("statusCode: " + res.statusCode);
                res.pipe(file);
                res.on("error", err => reject(err));
                res.on('data', d => body += d);
                res.on("end", () => {
                    file.end(null, null, file.close);
                    if (printData) {
                        tl.debug(body);
                    }
                    if (isDownloadSucceeded(res)) {
                        tl.debug("File download completed");
                        resolve();
                    }
                    else if (isRedirect(res) && handleRedirect) {
                        var redirectOptions = getRedirectOptions(options, res.headers.location);
                        resolve(this.download(redirectOptions, downloadPath, printData, false));
                    }
                    else {
                        tl.debug("File download failed");
                        reject(new Error('Failed to download file status code: ' + res.statusCode));
                    }
                });
            });
            req.on("error", err => {
                tl.debug(err);
                reject(err);
            });
            req.end();
        });
    });
}
exports.download = download;
