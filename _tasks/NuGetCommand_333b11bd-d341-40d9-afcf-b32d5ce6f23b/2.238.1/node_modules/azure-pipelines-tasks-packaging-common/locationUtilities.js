"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFeedRegistryUrl = exports.retryOnNullOrExceptionHelper = exports.retryOnExceptionHelper = exports.getWebApiWithProxy = exports.getSystemAccessToken = exports.getPackagingUris = exports.getBlobstoreUriFromBaseServiceUri = exports.getFeedUriFromBaseServiceUri = exports.getNuGetUriFromBaseServiceUri = exports.getServiceUriFromAreaId = exports.RegistryType = exports.ProtocolType = void 0;
const vsts = require("azure-devops-node-api");
const interfaces = require("azure-devops-node-api/interfaces/common/VSSInterfaces");
const tl = require("azure-pipelines-task-lib/task");
const provenance = require("./provenance");
var ProtocolType;
(function (ProtocolType) {
    ProtocolType[ProtocolType["NuGet"] = 0] = "NuGet";
    ProtocolType[ProtocolType["Maven"] = 1] = "Maven";
    ProtocolType[ProtocolType["Npm"] = 2] = "Npm";
    ProtocolType[ProtocolType["PyPi"] = 3] = "PyPi";
    ProtocolType[ProtocolType["Cargo"] = 4] = "Cargo";
})(ProtocolType = exports.ProtocolType || (exports.ProtocolType = {}));
var RegistryType;
(function (RegistryType) {
    RegistryType[RegistryType["npm"] = 0] = "npm";
    RegistryType[RegistryType["NuGetV2"] = 1] = "NuGetV2";
    RegistryType[RegistryType["NuGetV3"] = 2] = "NuGetV3";
    RegistryType[RegistryType["PyPiSimple"] = 3] = "PyPiSimple";
    RegistryType[RegistryType["PyPiUpload"] = 4] = "PyPiUpload";
})(RegistryType = exports.RegistryType || (exports.RegistryType = {}));
// Getting service urls from resource areas api
function getServiceUriFromAreaId(serviceUri, accessToken, areaId) {
    return __awaiter(this, void 0, void 0, function* () {
        const serverType = tl.getVariable('System.ServerType');
        if (!serverType || serverType.toLowerCase() !== 'hosted') {
            return serviceUri;
        }
        const webApi = getWebApiWithProxy(serviceUri, accessToken);
        const locationApi = yield webApi.getLocationsApi();
        tl.debug(`Getting URI for area ID ${areaId} from ${serviceUri}`);
        const resourceArea = yield retryOnExceptionHelper(() => locationApi.getResourceArea(areaId), 3, 1000);
        tl.debug(`Found resource area with locationUrl: ${resourceArea && resourceArea.locationUrl}`);
        return resourceArea.locationUrl;
    });
}
exports.getServiceUriFromAreaId = getServiceUriFromAreaId;
function getNuGetUriFromBaseServiceUri(serviceUri, accesstoken) {
    return __awaiter(this, void 0, void 0, function* () {
        const nugetAreaId = 'B3BE7473-68EA-4A81-BFC7-9530BAAA19AD';
        return getServiceUriFromAreaId(serviceUri, accesstoken, nugetAreaId);
    });
}
exports.getNuGetUriFromBaseServiceUri = getNuGetUriFromBaseServiceUri;
// Feeds url from location service
function getFeedUriFromBaseServiceUri(serviceUri, accesstoken) {
    return __awaiter(this, void 0, void 0, function* () {
        const feedAreaId = '7ab4e64e-c4d8-4f50-ae73-5ef2e21642a5';
        return getServiceUriFromAreaId(serviceUri, accesstoken, feedAreaId);
    });
}
exports.getFeedUriFromBaseServiceUri = getFeedUriFromBaseServiceUri;
function getBlobstoreUriFromBaseServiceUri(serviceUri, accesstoken) {
    return __awaiter(this, void 0, void 0, function* () {
        const blobAreaId = '5294ef93-12a1-4d13-8671-9d9d014072c8';
        return getServiceUriFromAreaId(serviceUri, accesstoken, blobAreaId);
    });
}
exports.getBlobstoreUriFromBaseServiceUri = getBlobstoreUriFromBaseServiceUri;
/**
 * PackagingLocation.PackagingUris:
 *  The first URI will always be the TFS collection URI
 *  The second URI, if existent, will be Packaging's default access point
 *  The remaining URI's will be alternate Packaging's access points
 */
function getPackagingUris(protocolType) {
    return __awaiter(this, void 0, void 0, function* () {
        tl.debug('Getting Packaging service access points');
        const collectionUrl = tl.getVariable('System.TeamFoundationCollectionUri');
        const pkgLocation = {
            PackagingUris: [collectionUrl],
            DefaultPackagingUri: collectionUrl
        };
        const serverType = tl.getVariable('System.ServerType');
        if (!serverType || serverType.toLowerCase() !== 'hosted') {
            return pkgLocation;
        }
        const accessToken = getSystemAccessToken();
        const areaId = getAreaIdForProtocol(protocolType);
        const serviceUri = yield getServiceUriFromAreaId(collectionUrl, accessToken, areaId);
        tl.debug(`Found serviceUri: ${serviceUri}`);
        const webApi = getWebApiWithProxy(serviceUri);
        const locationApi = yield webApi.getLocationsApi();
        tl.debug('Acquiring Packaging endpoints...');
        const connectionData = yield retryOnNullOrExceptionHelper(() => locationApi.getConnectionData(interfaces.ConnectOptions.IncludeServices), 3, 1000);
        tl.debug('Successfully acquired the connection data');
        const defaultAccessPoint = connectionData.locationServiceData.accessMappings.find((mapping) => mapping.moniker === connectionData.locationServiceData.defaultAccessMappingMoniker).accessPoint;
        pkgLocation.DefaultPackagingUri = defaultAccessPoint;
        pkgLocation.PackagingUris.push(defaultAccessPoint);
        pkgLocation.PackagingUris = pkgLocation.PackagingUris.concat(connectionData.locationServiceData.accessMappings.map((mapping) => {
            return mapping.accessPoint;
        }));
        tl.debug('Acquired location');
        tl.debug(JSON.stringify(pkgLocation));
        return pkgLocation;
    });
}
exports.getPackagingUris = getPackagingUris;
function getSystemAccessToken() {
    tl.debug('Getting credentials for local feeds');
    const auth = tl.getEndpointAuthorization('SYSTEMVSSCONNECTION', false);
    if (auth.scheme === 'OAuth') {
        tl.debug('Got auth token');
        return auth.parameters['AccessToken'];
    }
    else {
        tl.warning('Could not determine credentials to use');
    }
}
exports.getSystemAccessToken = getSystemAccessToken;
function getAreaIdForProtocol(protocolType) {
    switch (protocolType) {
        case ProtocolType.Maven:
            return '6F7F8C07-FF36-473C-BCF3-BD6CC9B6C066';
        case ProtocolType.Npm:
            return '4C83CFC1-F33A-477E-A789-29D38FFCA52E';
        default:
        case ProtocolType.NuGet:
            return 'B3BE7473-68EA-4A81-BFC7-9530BAAA19AD';
        case ProtocolType.Cargo:
            return '71F96160-8701-4914-AED9-C44B89F20CCD';
    }
}
function getWebApiWithProxy(serviceUri, accessToken) {
    if (!accessToken) {
        accessToken = getSystemAccessToken();
    }
    const credentialHandler = vsts.getBasicHandler('vsts', accessToken);
    const options = {
        proxy: tl.getHttpProxyConfiguration(serviceUri),
        allowRetries: true,
        maxRetries: 5
    };
    const webApi = new vsts.WebApi(serviceUri, credentialHandler, options);
    tl.debug(`Created webApi client for ${serviceUri}; options: ${JSON.stringify(options)}`);
    return webApi;
}
exports.getWebApiWithProxy = getWebApiWithProxy;
// This function is to apply retries generically for any unreliable network calls
function retryOnExceptionHelper(action, maxTries, retryIntervalInMilliseconds) {
    return __awaiter(this, void 0, void 0, function* () {
        while (true) {
            try {
                return yield action();
            }
            catch (error) {
                maxTries--;
                if (maxTries < 1) {
                    throw error;
                }
                tl.debug(`Network call failed. Number of retries left: ${maxTries}`);
                if (error) {
                    tl.debug(error);
                }
                yield delay(retryIntervalInMilliseconds);
            }
        }
    });
}
exports.retryOnExceptionHelper = retryOnExceptionHelper;
function retryOnNullOrExceptionHelper(action, maxTries, retryIntervalInMilliseconds) {
    return __awaiter(this, void 0, void 0, function* () {
        while (true) {
            try {
                var response = yield action();
                if (response === null || response === undefined) {
                    throw new Error("Response was null or undefined");
                }
                return response;
            }
            catch (error) {
                maxTries--;
                if (maxTries < 1) {
                    throw error;
                }
                tl.debug(`Response was null or undefined. Number of retries left: ${maxTries}`);
                if (error) {
                    tl.debug(error);
                }
                yield delay(retryIntervalInMilliseconds);
            }
        }
    });
}
exports.retryOnNullOrExceptionHelper = retryOnNullOrExceptionHelper;
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
;
function getFeedRegistryUrl(packagingUrl, registryType, feedId, project, accessToken, useSession) {
    return __awaiter(this, void 0, void 0, function* () {
        let loc;
        switch (registryType) {
            case RegistryType.npm:
                loc = {
                    apiVersion: '3.0-preview.1',
                    area: 'npm',
                    locationId: 'D9B75B07-F1D9-4A67-AAA6-A4D9E66B3352'
                };
                break;
            case RegistryType.NuGetV2:
                loc = {
                    apiVersion: '3.0-preview.1',
                    area: 'nuget',
                    locationId: "5D6FC3B3-EF78-4342-9B6E-B3799C866CFA"
                };
                break;
            case RegistryType.PyPiSimple:
                loc = {
                    apiVersion: '5.0',
                    area: 'pypi',
                    locationId: "93377A2C-F5FB-48B9-A8DC-7781441CABF1"
                };
                break;
            case RegistryType.PyPiUpload:
                loc = {
                    apiVersion: '5.0',
                    area: 'pypi',
                    locationId: "C7A75C1B-08AC-4B11-B468-6C7EF835C85E"
                };
                break;
            default:
            case RegistryType.NuGetV3:
                loc = {
                    apiVersion: '3.0-preview.1',
                    area: 'nuget',
                    locationId: "9D3A4E8E-2F8F-4AE1-ABC2-B461A51CB3B3"
                };
                break;
        }
        tl.debug("Getting registry url from " + packagingUrl);
        const vssConnection = getWebApiWithProxy(packagingUrl, accessToken);
        let sessionId = feedId;
        if (useSession) {
            sessionId = yield provenance.ProvenanceHelper.GetSessionId(feedId, project, loc.area /* protocol */, vssConnection.serverUrl, [vssConnection.authHandler], vssConnection.options);
        }
        const data = yield retryOnExceptionHelper(() => vssConnection.vsoClient.getVersioningData(loc.apiVersion, loc.area, loc.locationId, { feedId: sessionId, project: project }), 3, 1000);
        tl.debug("Feed registry url: " + data.requestUrl);
        return data.requestUrl;
    });
}
exports.getFeedRegistryUrl = getFeedRegistryUrl;
