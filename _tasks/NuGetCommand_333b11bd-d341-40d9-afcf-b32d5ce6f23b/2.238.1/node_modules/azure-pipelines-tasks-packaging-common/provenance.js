"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProvenanceHelper = void 0;
const tl = require("azure-pipelines-task-lib");
const vstsClientBases = require("azure-devops-node-api/ClientApiBases");
const util_1 = require("./util");
class ProvenanceHelper {
    /* Creates a session request with default data provided by the build variables */
    static CreateSessionRequest(feedId) {
        var releaseId = tl.getVariable("Release.ReleaseId");
        if (releaseId != null) {
            return ProvenanceHelper.CreateReleaseSessionRequest(feedId, releaseId);
        }
        var buildId = tl.getVariable("Build.BuildId");
        if (buildId != null) {
            return ProvenanceHelper.CreateBuildSessionRequest(feedId, buildId);
        }
        throw new Error("Could not resolve Release.ReleaseId or Build.BuildId");
    }
    static GetSessionId(feedId, project, protocol, baseUrl, handlers, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const publishPackageMetadata = tl.getInput("publishPackageMetadata");
            let shouldCreateSession = publishPackageMetadata && publishPackageMetadata.toLowerCase() == 'true';
            if (shouldCreateSession) {
                const useSessionEnabled = tl.getVariable("Packaging.SavePublishMetadata");
                shouldCreateSession = shouldCreateSession && !(useSessionEnabled && useSessionEnabled.toLowerCase() == 'false');
            }
            if (shouldCreateSession) {
                tl.debug("Creating provenance session to save pipeline metadata. This can be disabled in the task settings, or by setting build variable Packaging.SavePublishMetadata to false");
                const prov = new ProvenanceApi(baseUrl, handlers, options);
                const sessionRequest = ProvenanceHelper.CreateSessionRequest(feedId);
                try {
                    const session = yield prov.createSession(sessionRequest, protocol, project);
                    return session.sessionId;
                }
                catch (error) {
                    tl.warning(tl.loc("Warning_SessionCreationFailed"));
                    util_1.logError(error, util_1.LogType.warning);
                }
            }
            return feedId;
        });
    }
    static CreateReleaseSessionRequest(feedId, releaseId) {
        let releaseData = {
            "System.CollectionId": tl.getVariable("System.CollectionId"),
            "System.TeamProjectId": tl.getVariable("System.TeamProjectId"),
            "Release.ReleaseId": releaseId,
            "Release.ReleaseName": tl.getVariable("Release.ReleaseName"),
            "Release.DefinitionName": tl.getVariable("Release.DefinitionName"),
            "Release.DefinitionId": tl.getVariable("Release.DefinitionId")
        };
        var sessionRequest = {
            feed: feedId,
            source: "InternalRelease",
            data: releaseData
        };
        return sessionRequest;
    }
    static CreateBuildSessionRequest(feedId, buildId) {
        let buildData = {
            "System.CollectionId": tl.getVariable("System.CollectionId"),
            "System.DefinitionId": tl.getVariable("System.DefinitionId"),
            "System.TeamProjectId": tl.getVariable("System.TeamProjectId"),
            "Build.BuildId": buildId,
            "Build.BuildNumber": tl.getVariable("Build.BuildNumber"),
            "Build.DefinitionName": tl.getVariable("Build.DefinitionName"),
            "Build.Repository.Name": tl.getVariable("Build.Repository.Name"),
            "Build.Repository.Provider": tl.getVariable("Build.Repository.Provider"),
            "Build.Repository.Id": tl.getVariable("Build.Repository.Id"),
            "Build.Repository.Uri": tl.getVariable("Build.Repository.Uri"),
            "Build.SourceBranch": tl.getVariable("Build.SourceBranch"),
            "Build.SourceBranchName": tl.getVariable("Build.SourceBranchName"),
            "Build.SourceVersion": tl.getVariable("Build.SourceVersion")
        };
        var sessionRequest = {
            feed: feedId,
            source: "InternalBuild",
            data: buildData
        };
        return sessionRequest;
    }
}
exports.ProvenanceHelper = ProvenanceHelper;
class ProvenanceApi extends vstsClientBases.ClientApiBase {
    constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-packageprovenance-api", options);
    }
    /**
     * Creates a session, a wrapper around a feed that can store additional metadata on the packages published to the session.
     *
     * @param {SessionRequest} sessionRequest - The feed and metadata for the session
     * @param {string} protocol - The protocol that the session will target
     */
    createSession(sessionRequest, protocol, project) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let routeValues = {
                    protocol: protocol,
                    project: project
                };
                try {
                    let verData = yield this.vsoClient.getVersioningData("5.0-preview.1", "Provenance", "503B4E54-EBF4-4D04-8EEE-21C00823C2AC", routeValues);
                    let url = verData.requestUrl;
                    let options = this.createRequestOptions('application/json', verData.apiVersion);
                    let res;
                    res = yield this.rest.create(url, sessionRequest, options);
                    let ret = this.formatResponse(res.result, null, false);
                    resolve(ret);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
}
