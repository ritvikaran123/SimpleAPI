"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getServiceUriFromAreaId = exports.getBlobstoreUriFromBaseServiceUri = exports.getWebApiWithProxy = exports.trimEnd = exports.getClientToolFromService = exports.extractZip = exports.getSupportedOSType = exports.getSupportedArchitecture = exports.getSystemAccessToken = exports.retryOnExceptionHelper = exports.getClientToolLocation = void 0;
const AdmZip = require("adm-zip");
const vsts = require("azure-devops-node-api");
const os = require("os");
const path = require("path");
const tl = require("azure-pipelines-task-lib");
const toollib = require("azure-pipelines-tool-lib/tool");
function getClientToolLocation(dirName, toolName) {
    let toolPath = path.join(dirName, toolName);
    return toolPath;
}
exports.getClientToolLocation = getClientToolLocation;
// This function is to apply retries generically for any unreliable network calls
function retryOnExceptionHelper(action, maxTries, retryIntervalInMilliseconds) {
    return __awaiter(this, void 0, void 0, function* () {
        while (true) {
            try {
                return yield action();
            }
            catch (error) {
                maxTries--;
                if (maxTries < 1) {
                    throw error;
                }
                tl.debug(`Network call failed. Number of retries left: ${maxTries}`);
                if (error) {
                    tl.debug(error);
                }
                yield delay(retryIntervalInMilliseconds);
            }
        }
    });
}
exports.retryOnExceptionHelper = retryOnExceptionHelper;
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
function getSystemAccessToken() {
    tl.debug('Getting credentials for client tool');
    const auth = tl.getEndpointAuthorization('SYSTEMVSSCONNECTION', false);
    if (auth.scheme === 'OAuth') {
        tl.debug('Got auth token');
        return auth.parameters['AccessToken'];
    }
    else {
        tl.warning('Could not determine credentials to use');
    }
}
exports.getSystemAccessToken = getSystemAccessToken;
function _createExtractFolder(toolName, dest) {
    if (!dest) {
        // create a temp dir
        dest = path.join(tl.getVariable("Agent.TempDirectory"), toolName);
    }
    tl.mkdirP(dest);
    return dest;
}
function getSupportedArchitecture() {
    let architecture = os.arch();
    if (architecture === "x64") {
        architecture = "amd64";
    }
    // https://github.com/nodejs/node-v0.x-archive/issues/2862
    if (architecture == "ia32") {
        if (process.env.PROCESSOR_ARCHITEW6432 != null && process.env.PROCESSOR_ARCHITEW6432.toUpperCase() === "AMD64") {
            architecture = "amd64";
        }
    }
    if (architecture.toLowerCase() !== "amd64") {
        throw new Error(`The processing architecture of ${architecture} is not supported.`);
    }
    return architecture;
}
exports.getSupportedArchitecture = getSupportedArchitecture;
function getSupportedOSType() {
    switch (tl.osType()) {
        case 'Linux':
            return 'linux';
        case 'Windows_NT':
            return 'windows';
        case 'Darwin':
            return 'darwin';
        default:
            throw Error('Not Supported OS type');
    }
}
exports.getSupportedOSType = getSupportedOSType;
// there is a reason we do this instead of toollib.extractZip, but we don't recall what it is
// (might be Mac compatibility)
function extractZip(file, toolName) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!file) {
            throw new Error("parameter 'file' is required");
        }
        let dest = _createExtractFolder(toolName);
        let zip = new AdmZip(file);
        zip.extractAllTo(dest, true);
        return dest;
    });
}
exports.extractZip = extractZip;
function getClientToolFromService(serviceUri, accessToken, toolName) {
    return __awaiter(this, void 0, void 0, function* () {
        let osName = getSupportedOSType();
        let arch = getSupportedArchitecture();
        const overrideClientToolPath = tl.getVariable(toolName + ".OverrideClientToolPath");
        if (overrideClientToolPath != null) {
            return getClientToolLocation(overrideClientToolPath, toolName);
        }
        const blobstoreAreaName = "clienttools";
        const blobstoreAreaId = "187ec90d-dd1e-4ec6-8c57-937d979261e5";
        const ApiVersion = "5.0-preview";
        const blobstoreConnection = getWebApiWithProxy(serviceUri, accessToken);
        const clientToolGetUrl = yield blobstoreConnection.vsoClient.getVersioningData(ApiVersion, blobstoreAreaName, blobstoreAreaId, { toolName }, { osName, arch });
        const clientToolUri = yield blobstoreConnection.rest.get(clientToolGetUrl.requestUrl);
        if (clientToolUri.statusCode !== 200) {
            let errorMessage = `Could not get tool metadata from ${clientToolGetUrl.requestUrl} due to error (${clientToolUri.result.toString()}).`;
            tl.debug(errorMessage);
            throw new Error(errorMessage);
        }
        let clientToolPath = toollib.findLocalTool(toolName, clientToolUri.result['version']);
        if (!clientToolPath) {
            tl.debug(`Downloading client tool from ${clientToolUri.result['uri']}.`);
            const zippedToolsDir = yield retryOnExceptionHelper(() => toollib.downloadTool(clientToolUri.result['uri']), 3, 1000);
            tl.debug("Downloaded zipped client tool to " + zippedToolsDir);
            const unzippedToolsDir = yield extractZip(zippedToolsDir, toolName);
            clientToolPath = yield toollib.cacheDir(unzippedToolsDir, toolName, clientToolUri.result['version']);
        }
        else {
            tl.debug(`Client tool already found at ${clientToolPath}.`);
        }
        return getClientToolLocation(clientToolPath, toolName);
    });
}
exports.getClientToolFromService = getClientToolFromService;
// trim the given character if it exists in the end of string.
function trimEnd(data, trimChar) {
    if (!trimChar || !data) {
        return data;
    }
    if (data.endsWith(trimChar)) {
        return data.substring(0, data.length - trimChar.length);
    }
    else {
        return data;
    }
}
exports.trimEnd = trimEnd;
function getWebApiWithProxy(serviceUri, accessToken) {
    if (!accessToken) {
        accessToken = getSystemAccessToken();
    }
    const credentialHandler = vsts.getBasicHandler('vsts', accessToken);
    const options = {
        proxy: tl.getHttpProxyConfiguration(serviceUri),
        allowRetries: true,
        maxRetries: 5
    };
    const webApi = new vsts.WebApi(serviceUri, credentialHandler, options);
    tl.debug(`Created webApi client for ${serviceUri}; options: ${JSON.stringify(options)}`);
    return webApi;
}
exports.getWebApiWithProxy = getWebApiWithProxy;
function getBlobstoreUriFromBaseServiceUri(serviceUri, accesstoken) {
    return __awaiter(this, void 0, void 0, function* () {
        const blobAreaId = '5294ef93-12a1-4d13-8671-9d9d014072c8';
        return getServiceUriFromAreaId(serviceUri, accesstoken, blobAreaId);
    });
}
exports.getBlobstoreUriFromBaseServiceUri = getBlobstoreUriFromBaseServiceUri;
// Getting service urls from resource areas api
function getServiceUriFromAreaId(serviceUri, accessToken, areaId) {
    return __awaiter(this, void 0, void 0, function* () {
        const serverType = tl.getVariable('System.ServerType');
        if (!serverType || serverType.toLowerCase() !== 'hosted') {
            return serviceUri;
        }
        const webApi = getWebApiWithProxy(serviceUri, accessToken);
        const locationApi = yield webApi.getLocationsApi();
        tl.debug(`Getting URI for area ID ${areaId} from ${serviceUri}`);
        const resourceArea = yield retryOnExceptionHelper(() => locationApi.getResourceArea(areaId), 3, 1000);
        tl.debug(`Found resource area with locationUrl: ${resourceArea && resourceArea.locationUrl}`);
        return resourceArea.locationUrl;
    });
}
exports.getServiceUriFromAreaId = getServiceUriFromAreaId;
