"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTempNpmrcPath = exports.getLocalNpmRegistries = exports.getAllNpmRegistries = exports.getFeedIdFromRegistry = exports.getLocalRegistries = exports.appendToNpmrc = void 0;
const path = require("path");
const url = require("url");
const util = require("../util");
const tl = require("azure-pipelines-task-lib/task");
const npmregistry_1 = require("./npmregistry");
const NpmrcParser = require("./npmrcparser");
function appendToNpmrc(npmrc, data) {
    tl.writeFile(npmrc, data, {
        flag: 'a'
    });
}
exports.appendToNpmrc = appendToNpmrc;
function getLocalRegistries(packagingUrls, npmrc) {
    return __awaiter(this, void 0, void 0, function* () {
        const collectionHosts = packagingUrls.map((pkgUrl) => {
            const parsedUrl = url.parse(pkgUrl);
            if (parsedUrl && parsedUrl.host) {
                return parsedUrl.host.toLowerCase();
            }
            return undefined;
        });
        const registries = NpmrcParser.GetRegistries(npmrc, /* saveNormalizedRegistries */ true);
        const localRegistries = registries.filter(registry => {
            const registryUrl = url.parse(registry);
            if (registryUrl && registryUrl.host) {
                return collectionHosts.indexOf(registryUrl.host.toLowerCase()) >= 0;
            }
            return undefined;
        });
        tl.debug(tl.loc('FoundLocalRegistries', localRegistries.length));
        return localRegistries;
    });
}
exports.getLocalRegistries = getLocalRegistries;
function getFeedIdFromRegistry(registry) {
    const registryUrl = url.parse(registry);
    const registryPathname = registryUrl.pathname.toLowerCase();
    const startingToken = '/_packaging/';
    const startingIndex = registryPathname.indexOf(startingToken);
    const endingIndex = registryPathname.indexOf('/npm/registry');
    return registryUrl.pathname.substring(startingIndex + startingToken.length, endingIndex);
}
exports.getFeedIdFromRegistry = getFeedIdFromRegistry;
function getAllNpmRegistries(npmrcPath) {
    if (tl.exist(npmrcPath)) {
        return NpmrcParser.GetRegistries(npmrcPath, /* saveNormalizedRegistries */ false);
    }
    return [];
}
exports.getAllNpmRegistries = getAllNpmRegistries;
function getLocalNpmRegistries(workingDir, packagingUrls) {
    return __awaiter(this, void 0, void 0, function* () {
        const npmrcPath = path.join(workingDir, '.npmrc');
        if (tl.exist(npmrcPath)) {
            const localRegistries = yield getLocalRegistries(packagingUrls, npmrcPath);
            return localRegistries.map(registry => npmregistry_1.NpmRegistry.FromUrl(registry, true));
        }
        return [];
    });
}
exports.getLocalNpmRegistries = getLocalNpmRegistries;
function getTempNpmrcPath() {
    const id = tl.getVariable('Build.BuildId') || tl.getVariable('Release.ReleaseId');
    const tempUserNpmrcPath = path.join(util.getTempPath(), `${id}.npmrc`);
    return tempUserNpmrcPath;
}
exports.getTempNpmrcPath = getTempNpmrcPath;
