"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NpmRegistry = void 0;
const os = require("os");
const tl = require("azure-pipelines-task-lib/task");
const HttpClient_1 = require("typed-rest-client/HttpClient");
const npmrcparser_1 = require("./npmrcparser");
const util = require("../util");
const locationUtil = require("../locationUtilities");
class NpmRegistry {
    constructor(url, auth, authOnly) {
        this.url = url;
        this.auth = auth;
        this.authOnly = authOnly || false;
    }
    static FromServiceEndpoint(endpointId, authOnly) {
        return __awaiter(this, void 0, void 0, function* () {
            const lineEnd = os.EOL;
            let endpointAuth;
            let url;
            let nerfed;
            let auth;
            let username;
            let password;
            let email;
            let password64;
            let isVstsTokenAuth = false;
            try {
                endpointAuth = tl.getEndpointAuthorization(endpointId, false);
            }
            catch (exception) {
                throw new Error(tl.loc('ServiceEndpointNotDefined'));
            }
            try {
                url = npmrcparser_1.NormalizeRegistry(tl.getEndpointUrl(endpointId, false));
                // To the reader, this could be optimized here but it is broken out for readability
                if (endpointAuth.scheme === 'Token') {
                    isVstsTokenAuth = yield NpmRegistry.isEndpointInternal(url);
                }
                nerfed = util.toNerfDart(url);
            }
            catch (exception) {
                throw new Error(tl.loc('ServiceEndpointUrlNotDefined'));
            }
            switch (endpointAuth.scheme) {
                case 'UsernamePassword':
                    username = endpointAuth.parameters['username'];
                    password = endpointAuth.parameters['password'];
                    email = username; // npm needs an email to be set in order to publish, this is ignored on npmjs
                    password64 = (new Buffer(password).toString('base64'));
                    tl.setSecret(password64);
                    auth = nerfed + ':username=' + username + lineEnd;
                    auth += nerfed + ':_password=' + password64 + lineEnd;
                    auth += nerfed + ':email=' + email + lineEnd;
                    break;
                case 'Token':
                    const apitoken = endpointAuth.parameters['apitoken'];
                    if (!isVstsTokenAuth) {
                        // Use Bearer auth as it was intended.
                        auth = nerfed + ':_authToken=' + apitoken + lineEnd;
                    }
                    else {
                        // Azure DevOps does not support PATs+Bearer only JWTs+Bearer
                        email = 'VssEmail';
                        username = 'VssToken';
                        password64 = (new Buffer(apitoken).toString('base64'));
                        tl.setSecret(password64);
                        auth = nerfed + ':username=' + username + lineEnd;
                        auth += nerfed + ':_password=' + password64 + lineEnd;
                        auth += nerfed + ':email=' + email + lineEnd;
                    }
                    break;
            }
            auth += nerfed + ':always-auth=true';
            return new NpmRegistry(url, auth, authOnly);
        });
    }
    // make a request to the endpoint uri, and take a look at the response header to
    // determine whether this is our service, or an external service.
    static isEndpointInternal(endpointUri) {
        return __awaiter(this, void 0, void 0, function* () {
            let requestOptions;
            try {
                const proxy = tl.getHttpProxyConfiguration();
                requestOptions = proxy ? { proxy } : {};
            }
            catch (error) {
                tl.debug('unable to determine proxy configuration: ' + error);
                requestOptions = {};
            }
            const headers = {};
            headers['X-TFS-FedAuthRedirect'] = 'Suppress';
            const endpointClient = new HttpClient_1.HttpClient(tl.getVariable('AZURE_HTTP_USER_AGENT'), null, requestOptions);
            try {
                const resp = yield endpointClient.get(endpointUri, headers);
                return resp.message.rawHeaders !== null && resp.message.rawHeaders.some(t => t.toLowerCase().indexOf('x-tfs') >= 0 || t.toLowerCase().indexOf('x-vss') >= 0);
            }
            catch (error) {
                tl.debug(error);
                return false;
            }
        });
    }
    static FromFeedId(packagingUri, feedId, project, authOnly, useSession) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = npmrcparser_1.NormalizeRegistry(yield locationUtil.getFeedRegistryUrl(packagingUri, locationUtil.RegistryType.npm, feedId, project, null, useSession));
            return NpmRegistry.FromUrl(url, authOnly);
        });
    }
    static FromUrl(url, authOnly) {
        const nerfed = util.toNerfDart(url);
        const auth = `${nerfed}:_authToken=${locationUtil.getSystemAccessToken()}`;
        return new NpmRegistry(url, auth, authOnly);
    }
}
exports.NpmRegistry = NpmRegistry;
