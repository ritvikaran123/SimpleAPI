"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNuGetProxyFromEnvironment = exports.isCredentialConfigEnabled = exports.isCredentialProviderEnabled = exports.getNuGetQuirksAsync = exports.locateNuGetExe = exports.locateTool = exports.createNuGetToolRunner = exports.NuGetToolRunner = void 0;
const path = require("path");
const url = require("url");
const tl = require("azure-pipelines-task-lib/task");
const toolrunner_1 = require("azure-pipelines-task-lib/toolrunner");
const NuGetQuirks_1 = require("./NuGetQuirks");
const ngutil = require("./Utility");
const peParser = require("../pe-parser");
function prepareNuGetExeEnvironment(input, settings) {
    let env = {};
    let originalCredProviderPath;
    for (let e in input) {
        if (!input.hasOwnProperty(e)) {
            continue;
        }
        // NuGet.exe extensions only work with a single specific version of nuget.exe. This causes problems
        // whenever we update nuget.exe on the agent.
        if (e.toUpperCase() === "NUGET_EXTENSIONS_PATH") {
            if (settings.extensionsDisabled) {
                tl.warning(tl.loc("NGCommon_IgnoringNuGetExtensionsPath"));
                continue;
            }
            else {
                console.log(tl.loc("NGCommon_DetectedNuGetExtensionsPath", input[e]));
            }
        }
        if (e.toUpperCase() === "NUGET_CREDENTIALPROVIDERS_PATH") {
            originalCredProviderPath = input[e];
            // will re-set this variable below
            continue;
        }
        env[e] = input[e];
    }
    let credProviderPath = settings.credProviderFolder || originalCredProviderPath;
    if (settings.credProviderFolder && originalCredProviderPath) {
        credProviderPath = settings.credProviderFolder + ";" + originalCredProviderPath;
    }
    env["VSS_NUGET_ACCESSTOKEN"] = settings.authInfo.accessToken;
    env["VSS_NUGET_URI_PREFIXES"] = settings.authInfo.uriPrefixes.join(";");
    env["NUGET_CREDENTIAL_PROVIDER_OVERRIDE_DEFAULT"] = "true";
    if (credProviderPath) {
        tl.debug(`credProviderPath = ${credProviderPath}`);
        env["NUGET_CREDENTIALPROVIDERS_PATH"] = credProviderPath;
    }
    let httpProxy = getNuGetProxyFromEnvironment();
    if (httpProxy) {
        tl.debug(`Adding environment variable for NuGet proxy: ${httpProxy}`);
        env["HTTP_PROXY"] = httpProxy;
    }
    return env;
}
class NuGetToolRunner extends toolrunner_1.ToolRunner {
    constructor(nuGetExePath, settings) {
        if (tl.osType() === 'Windows_NT' || !nuGetExePath.trim().toLowerCase().endsWith(".exe")) {
            super(nuGetExePath);
        }
        else {
            let monoPath = tl.which("mono", true);
            super(monoPath);
            this.arg(nuGetExePath);
        }
        this.settings = settings;
    }
    execSync(options) {
        options = options || {};
        options.env = prepareNuGetExeEnvironment(options.env || process.env, this.settings);
        return super.execSync(options);
    }
    exec(options) {
        options = options || {};
        options.env = prepareNuGetExeEnvironment(options.env || process.env, this.settings);
        return super.exec(options);
    }
}
exports.NuGetToolRunner = NuGetToolRunner;
function createNuGetToolRunner(nuGetExePath, settings) {
    nuGetExePath = ngutil.resolveToolPath(nuGetExePath);
    let runner = new NuGetToolRunner(nuGetExePath, settings);
    runner.on("debug", message => tl.debug(message));
    return runner;
}
exports.createNuGetToolRunner = createNuGetToolRunner;
function locateTool(tool, opts) {
    const defaultSearchPath = ["externals/nuget", "agent/Worker/Tools/NuGetCredentialProvider", "agent/Worker/Tools"];
    const defaultAgentRoot = tl.getVariable("Agent.HomeDirectory");
    opts = opts || {};
    opts.toolFilenames = opts.toolFilenames || [tool];
    let searchPath = opts.searchPath || defaultSearchPath;
    let agentRoot = opts.root || defaultAgentRoot;
    tl.debug(`looking for tool ${tool}`);
    for (let thisVariant of opts.toolFilenames) {
        tl.debug(`looking for tool variant ${thisVariant}`);
        for (let possibleLocation of searchPath) {
            let fullPath = path.join(agentRoot, possibleLocation, thisVariant);
            tl.debug(`checking ${fullPath}`);
            if (tl.exist(fullPath)) {
                return fullPath;
            }
        }
        if (opts.fallbackToSystemPath) {
            tl.debug("Checking system path");
            let whichResult = tl.which(thisVariant);
            if (whichResult) {
                tl.debug(`found ${whichResult}`);
                return whichResult;
            }
        }
        tl.debug("not found");
    }
    return null;
}
exports.locateTool = locateTool;
function locateNuGetExe(userNuGetExePath) {
    if (userNuGetExePath) {
        if (tl.osType() === 'Windows_NT') {
            userNuGetExePath = ngutil.stripLeadingAndTrailingQuotes(userNuGetExePath);
        }
        tl.debug(`using user-supplied NuGet path ${userNuGetExePath}`);
        tl.checkPath(userNuGetExePath, "NuGet");
        return userNuGetExePath;
    }
    let toolPath = locateTool("NuGet", {
        fallbackToSystemPath: tl.osType() !== 'Windows_NT',
        toolFilenames: ["nuget.exe", "NuGet.exe", "nuget", "NuGet"],
    });
    if (!toolPath) {
        throw new Error(tl.loc("NGCommon_UnableToFindTool", "NuGet"));
    }
    return toolPath;
}
exports.locateNuGetExe = locateNuGetExe;
function getNuGetQuirksAsync(nuGetExePath) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const version = yield peParser.getFileVersionInfoAsync(nuGetExePath);
            const quirks = NuGetQuirks_1.NuGetQuirks.fromVersion(version.fileVersion);
            console.log(tl.loc("NGCommon_DetectedNuGetVersion", version.fileVersion, version.strings.ProductVersion));
            tl.debug(`Quirks for ${version.fileVersion}:`);
            quirks.getQuirkNames().forEach(quirk => {
                tl.debug(`    ${quirk}`);
            });
            return quirks;
        }
        catch (err) {
            if (err.code && (err.code === "invalidSignature"
                || err.code === "noResourceSection"
                || err.code === "noVersionResource")) {
                tl.debug("Cannot read version from NuGet. Using default quirks:");
                NuGetQuirks_1.defaultQuirks.forEach(quirk => {
                    tl.debug(`    ${NuGetQuirks_1.NuGetQuirkName[quirk]}`);
                });
                return new NuGetQuirks_1.NuGetQuirks(null, NuGetQuirks_1.defaultQuirks);
            }
            throw err;
        }
    });
}
exports.getNuGetQuirksAsync = getNuGetQuirksAsync;
function isOnPremisesTfs() {
    if (tl.getVariable("NuGetTasks.IsHostedTestEnvironment") === "true") {
        return false;
    }
    const serverType = tl.getVariable("System.ServerType");
    if (serverType) {
        return serverType.toLowerCase() !== "hosted";
    }
    else {
        // Placed here as fallback in case the variable above is not defined
        // not an ideal way to detect hosted, but there isn't a variable for it, and
        // we can't make network calls from here due to proxy issues.
        const collectionUri = tl.getVariable("System.TeamFoundationCollectionUri");
        const parsedCollectionUri = url.parse(collectionUri);
        return !(/\.visualstudio\.com$/i.test(parsedCollectionUri.hostname));
    }
}
// Currently, there is a race condition of some sort that causes nuget to not send credentials sometimes
// when using the credential provider.
// Unfortunately, on on-premises TFS, we must use credential provider to override NTLM auth with the build
// identity's token.
// Therefore, we are enabling credential provider on on-premises and disabling it on hosted. We allow for test
// instances by an override variable.
function isCredentialProviderEnabled(quirks) {
    // set NuGet.ForceEnableCredentialProvider to "true" to force allowing the credential provider flow, "false"
    // to force *not* allowing the credential provider flow, or unset/anything else to fall through to the 
    // hosted environment detection logic
    const credentialProviderOverrideFlag = tl.getVariable("NuGet.ForceEnableCredentialProvider");
    if (credentialProviderOverrideFlag === "true") {
        tl.debug("Credential provider is force-enabled for testing purposes.");
        return true;
    }
    if (credentialProviderOverrideFlag === "false") {
        tl.debug("Credential provider is force-disabled for testing purposes.");
        return false;
    }
    if (quirks.hasQuirk(NuGetQuirks_1.NuGetQuirkName.NoCredentialProvider)
        || quirks.hasQuirk(NuGetQuirks_1.NuGetQuirkName.CredentialProviderRace)) {
        tl.debug("Credential provider is disabled due to quirks.");
        return false;
    }
    if (isOnPremisesTfs() && (quirks.hasQuirk(NuGetQuirks_1.NuGetQuirkName.NoTfsOnPremAuthCredentialProvider))) {
        tl.debug("Credential provider is disabled due to on-prem quirks.");
        return false;
    }
    tl.debug("Credential provider is enabled.");
    return true;
}
exports.isCredentialProviderEnabled = isCredentialProviderEnabled;
function isCredentialConfigEnabled(quirks) {
    // set NuGet.ForceEnableCredentialConfig to "true" to force allowing config-based credential flow, "false"
    // to force *not* allowing config-based credential flow, or unset/anything else to fall through to the 
    // hosted environment detection logic
    const credentialConfigOverrideFlag = tl.getVariable("NuGet.ForceEnableCredentialConfig");
    if (credentialConfigOverrideFlag === "true") {
        tl.debug("Credential config is force-enabled for testing purposes.");
        return true;
    }
    if (credentialConfigOverrideFlag === "false") {
        tl.debug("Credential config is force-disabled for testing purposes.");
        return false;
    }
    if (isOnPremisesTfs() && (quirks.hasQuirk(NuGetQuirks_1.NuGetQuirkName.NoTfsOnPremAuthConfig))) {
        tl.debug("Credential config is disabled due to on-prem quirks.");
        return false;
    }
    tl.debug("Credential config is enabled.");
    return true;
}
exports.isCredentialConfigEnabled = isCredentialConfigEnabled;
function getNuGetProxyFromEnvironment() {
    let proxyUrl = tl.getVariable("agent.proxyurl");
    let proxyUsername = tl.getVariable("agent.proxyusername");
    let proxyPassword = tl.getVariable("agent.proxypassword");
    if (proxyUrl !== undefined) {
        let proxy = url.parse(proxyUrl);
        if (proxyUsername !== undefined) {
            proxy.auth = proxyUsername;
            if (proxyPassword !== undefined) {
                proxy.auth += `:${proxyPassword}`;
            }
        }
        return url.format(proxy);
    }
    return undefined;
}
exports.getNuGetProxyFromEnvironment = getNuGetProxyFromEnvironment;
