"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NuGetXmlHelper = void 0;
const fs = require("fs");
const ltx = require("ltx");
const tl = require("azure-pipelines-task-lib/task");
class NuGetXmlHelper {
    constructor(_nugetConfigPath) {
        this._nugetConfigPath = _nugetConfigPath;
    }
    SetApiKeyInNuGetConfig(source, apiKey) {
        throw new Error(tl.loc("Error_ApiKeyNotSupported"));
    }
    AddSourceToNuGetConfig(name, source, username, password) {
        NuGetXmlHelper._updateXmlFile(this._nugetConfigPath, (xml) => {
            if (xml) {
                NuGetXmlHelper._validateXmlIsConfiguration(xml);
                let xmlPackageSources = NuGetXmlHelper._getOrCreateLastElement(xml, "packageSources");
                let xmlSource = xmlPackageSources.c("add", {
                    key: name,
                    value: source
                });
                if (username || password) {
                    if (!username || !password) {
                        tl.debug("Adding NuGet source with username and password, but one of them is missing.");
                    }
                    xml = this._addCredentialsToSource(xml, name, username, password);
                }
            }
            return xml;
        });
    }
    RemoveSourceFromNuGetConfig(name) {
        NuGetXmlHelper._updateXmlFile(this._nugetConfigPath, (xml) => {
            if (xml) {
                NuGetXmlHelper._validateXmlIsConfiguration(xml);
                let xmlSources = xml.getChildrenByFilter((child) => {
                    return typeof (child) === "object" &&
                        child.getName().toLowerCase() === "add" &&
                        child.up().getName().toLowerCase() === "packagesources" &&
                        child.attrs.key === name;
                }, true);
                xmlSources.forEach((xmlSource) => {
                    xmlSource.up().remove(xmlSource);
                });
                xml = this._removeSourceCredentials(xml, name);
            }
            return xml;
        });
    }
    _addCredentialsToSource(xml, name, username, password) {
        if (xml) {
            const xmlSourceCredentials = NuGetXmlHelper._getOrCreateLastElement(xml, "packageSourceCredentials");
            const encodedName = NuGetXmlHelper._nuGetEncodeElementName(name);
            const authTypesVar = "ValidAuthenticationTypes_" + encodedName;
            const xmlFeedName = xmlSourceCredentials.c(encodedName);
            let authTypes = tl.getVariable(authTypesVar);
            if (!authTypes) {
                if (username !== "VssSessionToken") {
                    console.log(tl.loc("Info_BasicCredRestriction", authTypesVar, 'negotiate,ntlm'));
                }
                authTypes = 'basic';
            }
            xmlFeedName.c("add", {
                key: "Username",
                value: username
            });
            xmlFeedName.c("add", {
                key: "ClearTextPassword",
                value: password
            });
            xmlFeedName.c("add", {
                key: "ValidAuthenticationTypes",
                value: authTypes
            });
        }
        return xml;
    }
    _removeSourceCredentials(xml, name) {
        if (xml) {
            let xmlSourceCredentials = xml.getChildrenByFilter((child) => {
                return typeof (child) === "object" &&
                    child.getName() === NuGetXmlHelper._nuGetEncodeElementName(name) &&
                    child.up().getName().toLowerCase() === "packagesourcecredentials";
            }, true);
            xmlSourceCredentials.forEach((xmlCredentials) => {
                xmlCredentials.up().remove(xmlCredentials);
            });
        }
        return xml;
    }
    /**
     * Validates the xml element is a configuration element
     * @throws Will throw an error if the xml is not a configuration element
     * @param xml Xml Element
     */
    static _validateXmlIsConfiguration(xml) {
        if (xml) {
            if (xml.getName().toLowerCase() !== "configuration") {
                throw Error(tl.loc("Error_ExpectedConfigurationElement"));
            }
        }
    }
    /**
     * Gets the last element in xml that matches elementName. If no existing element is found,
     * one will be created on the root of xml
     * @param xml Xml Element to search
     * @param elementName Element name to return or create
     */
    static _getOrCreateLastElement(xml, elementName) {
        if (xml) {
            let xmlElements = xml.getChildren(elementName);
            if (!xmlElements || xmlElements.length === 0) {
                xmlElements = [xml.c(elementName)];
            }
            return xmlElements[xmlElements.length - 1];
        }
    }
    static _updateXmlFile(xmlPath, updateFn) {
        let xmlString = fs.readFileSync(xmlPath).toString();
        // strip BOM; xml parser doesn't like it
        if (xmlString.charCodeAt(0) === 0xFEFF) {
            xmlString = xmlString.substr(1);
        }
        let xml = ltx.parse(xmlString);
        xml = updateFn(xml);
        fs.writeFileSync(xmlPath, xml.root().toString());
    }
    static _nuGetEncodeElementName(name) {
        if (!name || name.length === 0) {
            return name;
        }
        // replace the following
        const invalidCharacters = [" ", ":"];
        for (let i = 1; i < name.length; i++) {
            if (invalidCharacters.indexOf(name[i]) >= 0) {
                name = name.substr(0, i) + NuGetXmlHelper._nuGetEncodeCharater(name[i]) + name.substr(i + 1);
            }
        }
        // if the first character is a number, encode it
        if (isNaN(parseInt(name.charAt(0)))) {
            return name;
        }
        let firstCharHex = NuGetXmlHelper._nuGetEncodeCharater(name[0]);
        return firstCharHex + name.substr(1);
    }
    static _nuGetEncodeCharater(char) {
        let hexValue = char.charCodeAt(0).toString(16);
        // pad
        while (hexValue.length < 4) {
            hexValue = "0" + hexValue;
        }
        return `_x${hexValue}_`;
    }
}
exports.NuGetXmlHelper = NuGetXmlHelper;
