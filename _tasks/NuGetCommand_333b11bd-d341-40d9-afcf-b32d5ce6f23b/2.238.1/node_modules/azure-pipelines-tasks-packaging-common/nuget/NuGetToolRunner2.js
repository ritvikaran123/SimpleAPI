"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProxyBypassForConfig = exports.getProxyBypassForUri = exports.getNuGetProxyFromEnvironment = exports.isCredentialConfigEnabled = exports.isCredentialProviderV2Enabled = exports.isCredentialProviderEnabled = exports.getNuGetQuirksAsync = exports.createNuGetToolRunner = exports.NuGetToolRunner2 = exports.setNuGetProxyEnvironment = void 0;
const url = require("url");
const tl = require("azure-pipelines-task-lib/task");
const toolrunner_1 = require("azure-pipelines-task-lib/toolrunner");
const auth = require("./Authentication");
const NuGetQuirks_1 = require("./NuGetQuirks");
const ngutil = require("./Utility");
const peParser = require("../pe-parser");
const commandHelper = require("./CommandHelper");
const path = require("path");
function prepareNuGetExeEnvironment(input, settings, authInfo) {
    let env = {};
    let originalCredProviderPath = null;
    let envVarCredProviderPathV2 = null;
    let nugetCacheDir = null;
    let disableNuGetPluginCacheWorkaround = false;
    for (let e in input) {
        if (!input.hasOwnProperty(e)) {
            continue;
        }
        // NuGet.exe extensions only work with a single specific version of nuget.exe. This causes problems
        // whenever we update nuget.exe on the agent.
        if (e.toUpperCase() === "NUGET_EXTENSIONS_PATH") {
            if (settings.extensionsDisabled) {
                tl.warning(tl.loc("NGCommon_IgnoringNuGetExtensionsPath"));
                continue;
            }
            else {
                console.log(tl.loc("NGCommon_DetectedNuGetExtensionsPath", input[e]));
            }
        }
        // New credential provider
        if (e.toUpperCase() === "NUGET_PLUGIN_PATHS") {
            envVarCredProviderPathV2 = input[e];
            continue;
        }
        // Old credential provider
        if (e.toUpperCase() === "NUGET_CREDENTIALPROVIDERS_PATH") {
            originalCredProviderPath = input[e];
            continue;
        }
        if (e.toUpperCase() === "DISABLE_NUGET_PLUGINS_CACHE_WORKAROUND") {
            // Specifically disable NUGET_PLUGINS_CACHE_PATH workaround
            disableNuGetPluginCacheWorkaround = true;
            continue;
        }
        // NuGet plugins cache
        if (e.toUpperCase() === "NUGET_PLUGINS_CACHE_PATH") {
            nugetCacheDir = input[e];
            continue;
        }
        env[e] = input[e];
    }
    // If DISABLE_NUGET_PLUGINS_CACHE_WORKAROUND variable is not set 
    // and nugetCacheDir is not populated by NUGET_PLUGINS_CACHE_PATH,
    // set NUGET_PLUGINS_CACHE_PATH to the temp directory
    // to work aroud the NuGet issue with long paths: https://github.com/NuGet/Home/issues/7770
    if (nugetCacheDir == null && disableNuGetPluginCacheWorkaround === false) {
        const tempDir = tl.getVariable('Agent.TempDirectory');
        nugetCacheDir = path.join(tempDir, "NuGetPluginsCache");
    }
    if (nugetCacheDir != null) {
        env["NUGET_PLUGINS_CACHE_PATH"] = nugetCacheDir;
        tl.debug(`NUGET_PLUGINS_CACHE_PATH set to ${nugetCacheDir}`);
    }
    if (authInfo && authInfo.internalAuthInfo) {
        env["VSS_NUGET_ACCESSTOKEN"] = authInfo.internalAuthInfo.accessToken;
        env["VSS_NUGET_URI_PREFIXES"] = authInfo.internalAuthInfo.uriPrefixes.join(";");
    }
    env["NUGET_CREDENTIAL_PROVIDER_OVERRIDE_DEFAULT"] = "true";
    // Old credential provider
    if (settings.credProviderFolder != null || originalCredProviderPath != null) {
        let credProviderPath = buildCredProviderPath(originalCredProviderPath, settings.credProviderFolder);
        if (credProviderPath) {
            env["NUGET_CREDENTIALPROVIDERS_PATH"] = credProviderPath;
            tl.debug(`V1 credential provider set`);
            tl.debug(`credProviderPath = ${credProviderPath}`);
        }
    }
    // New credential provider
    if (settings.V2CredProviderPath != null || envVarCredProviderPathV2 != null) {
        let credProviderPath = buildCredProviderPath(envVarCredProviderPathV2, settings.V2CredProviderPath);
        if (credProviderPath) {
            env["NUGET_PLUGIN_PATHS"] = credProviderPath;
            tl.debug(`V2 credential provider set`);
            tl.debug(`credProviderPath = ${credProviderPath}`);
        }
        // NuGet restore task will pass external credentials to V2 credential provider
        let externalCredentials = buildCredentialJson(authInfo);
        if (externalCredentials) {
            env["VSS_NUGET_EXTERNAL_FEED_ENDPOINTS"] = externalCredentials;
        }
    }
    env = setNuGetProxyEnvironment(env, settings.configFile, settings.registryUri);
    return env;
}
// Adds the HTTP_PROXY and NO_PROXY values (if applicable) to the input dictionary
function setNuGetProxyEnvironment(input, configFile, registryUri) {
    let httpProxy = getNuGetProxyFromEnvironment();
    if (httpProxy) {
        tl.debug(`Adding environment variable for NuGet proxy: HTTP_PROXY`);
        input["HTTP_PROXY"] = httpProxy;
        let proxybypass;
        if (configFile != null) {
            proxybypass = getProxyBypassForConfig(configFile);
        }
        else if (registryUri != null) {
            proxybypass = getProxyBypassForUri(registryUri);
        }
        if (proxybypass) {
            tl.debug(`Adding environment variable for NuGet proxy bypass: NO_PROXY`);
            // check if there are any existing NO_PROXY values
            let existingNoProxy = process.env["NO_PROXY"];
            if (existingNoProxy) {
                existingNoProxy = existingNoProxy.trimRight();
                // trim trailing comma
                existingNoProxy = existingNoProxy.endsWith(',') ? existingNoProxy.slice(0, -1) : existingNoProxy;
                // append our bypass list
                proxybypass = existingNoProxy + ',' + proxybypass;
            }
            input["NO_PROXY"] = proxybypass;
        }
    }
    return input;
}
exports.setNuGetProxyEnvironment = setNuGetProxyEnvironment;
function buildCredProviderPath(credProviderPath1, credProviderPath2) {
    if (credProviderPath1 && credProviderPath2) {
        return credProviderPath1 + ";" + credProviderPath2;
    }
    return credProviderPath1 || credProviderPath2;
}
class NuGetToolRunner2 extends toolrunner_1.ToolRunner {
    constructor(nuGetExePath, settings, authInfo) {
        if (tl.osType() === 'Windows_NT' || !nuGetExePath.trim().toLowerCase().endsWith(".exe")) {
            super(nuGetExePath);
        }
        else {
            let monoPath = tl.which("mono", true);
            super(monoPath);
            this.arg(nuGetExePath);
        }
        this.settings = settings;
        this.authInfo = authInfo;
    }
    execSync(options) {
        options = options || {};
        options.env = prepareNuGetExeEnvironment(options.env || process.env, this.settings, this.authInfo);
        return super.execSync(options);
    }
    exec(options) {
        options = options || {};
        options.env = prepareNuGetExeEnvironment(options.env || process.env, this.settings, this.authInfo);
        return super.exec(options);
    }
}
exports.NuGetToolRunner2 = NuGetToolRunner2;
function createNuGetToolRunner(nuGetExePath, settings, authInfo) {
    nuGetExePath = ngutil.resolveToolPath(nuGetExePath);
    let runner = new NuGetToolRunner2(nuGetExePath, settings, authInfo);
    runner.on("debug", message => tl.debug(message));
    return runner;
}
exports.createNuGetToolRunner = createNuGetToolRunner;
function getNuGetQuirksAsync(nuGetExePath) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const version = yield peParser.getFileVersionInfoAsync(nuGetExePath);
            const quirks = NuGetQuirks_1.NuGetQuirks.fromVersion(version.fileVersion);
            console.log(tl.loc("NGCommon_DetectedNuGetVersion", version.fileVersion, version.strings.ProductVersion));
            tl.debug(`Quirks for ${version.fileVersion}:`);
            quirks.getQuirkNames().forEach(quirk => {
                tl.debug(`    ${quirk}`);
            });
            return quirks;
        }
        catch (err) {
            if (err.code && (err.code === "invalidSignature"
                || err.code === "noResourceSection"
                || err.code === "noVersionResource")) {
                tl.debug("Cannot read version from NuGet. Using default quirks:");
                NuGetQuirks_1.defaultQuirks.forEach(quirk => {
                    tl.debug(`    ${NuGetQuirks_1.NuGetQuirkName[quirk]}`);
                });
                return new NuGetQuirks_1.NuGetQuirks(null, NuGetQuirks_1.defaultQuirks);
            }
            throw err;
        }
    });
}
exports.getNuGetQuirksAsync = getNuGetQuirksAsync;
// Currently, there is a race condition of some sort that causes nuget to not send credentials sometimes
// when using the credential provider.
// Unfortunately, on on-premises TFS, we must use credential provider to override NTLM auth with the build
// identity's token.
// Therefore, we are enabling credential provider on on-premises and disabling it on hosted (only when the version of NuGet does not support it). We allow for test
// instances by an override variable.
// This checks if V1 credential provider is enabled
function isCredentialProviderEnabled(quirks) {
    // set NuGet.ForceEnableCredentialProvider to "true" to force allowing the credential provider flow, "false"
    // to force *not* allowing the credential provider flow, or unset/anything else to fall through to the 
    // hosted environment detection logic
    const credentialProviderOverrideFlag = tl.getVariable("NuGet.ForceEnableCredentialProvider"); // forces V1 credential provider
    if (credentialProviderOverrideFlag === "true") {
        tl.debug("V1 credential provider is force-enabled for testing purposes.");
        return true;
    }
    if (credentialProviderOverrideFlag === "false") {
        tl.debug("V1 credential provider is force-disabled for testing purposes.");
        return false;
    }
    const isWindows = tl.osType() === "Windows_NT";
    if (quirks.hasQuirk(NuGetQuirks_1.NuGetQuirkName.V2CredentialProvider) === true && isWindows) {
        tl.debug("Credential provider V1 is disabled in favor of V2 plugin.");
        return false;
    }
    if (isAnyCredentialProviderEnabled(quirks)) {
        tl.debug("V1 credential provider is enabled");
        return true;
    }
    return false;
}
exports.isCredentialProviderEnabled = isCredentialProviderEnabled;
// This checks if V2 credential provider is enabled
function isCredentialProviderV2Enabled(quirks) {
    const credentialProviderOverrideFlagV2 = tl.getVariable("NuGet_ForceEnableCredentialProviderV2");
    if (credentialProviderOverrideFlagV2 === "true") {
        tl.debug("V2 Credential provider is force-enabled.");
        return true;
    }
    if (credentialProviderOverrideFlagV2 === "false") {
        tl.debug("V2 Credential provider is force-disabled.");
        return false;
    }
    if (isAnyCredentialProviderEnabled(quirks) === false) {
        return false;
    }
    const isWindows = tl.osType() === "Windows_NT";
    if (quirks.hasQuirk(NuGetQuirks_1.NuGetQuirkName.V2CredentialProvider) === true && isWindows) {
        tl.debug("V2 credential provider is enabled.");
        return true;
    }
    tl.debug("V2 credential provider is disabled.");
    return false;
}
exports.isCredentialProviderV2Enabled = isCredentialProviderV2Enabled;
function isAnyCredentialProviderEnabled(quirks) {
    if (quirks.hasQuirk(NuGetQuirks_1.NuGetQuirkName.NoCredentialProvider)
        || quirks.hasQuirk(NuGetQuirks_1.NuGetQuirkName.CredentialProviderRace)) {
        tl.debug("Credential provider is disabled due to quirks.");
        return false;
    }
    if (commandHelper.isOnPremisesTfs() && (quirks.hasQuirk(NuGetQuirks_1.NuGetQuirkName.NoTfsOnPremAuthCredentialProvider))) {
        tl.debug("Credential provider is disabled due to on-prem quirks.");
        return false;
    }
    return true;
}
function isCredentialConfigEnabled(quirks) {
    // set NuGet.ForceEnableCredentialConfig to "true" to force allowing config-based credential flow, "false"
    // to force *not* allowing config-based credential flow, or unset/anything else to fall through to the 
    // hosted environment detection logic
    const credentialConfigOverrideFlag = tl.getVariable("NuGet.ForceEnableCredentialConfig");
    if (credentialConfigOverrideFlag === "true") {
        tl.debug("Credential config is force-enabled for testing purposes.");
        return true;
    }
    if (credentialConfigOverrideFlag === "false") {
        tl.debug("Credential config is force-disabled for testing purposes.");
        return false;
    }
    if (commandHelper.isOnPremisesTfs() && (quirks.hasQuirk(NuGetQuirks_1.NuGetQuirkName.NoTfsOnPremAuthConfig))) {
        tl.debug("Credential config is disabled due to on-prem quirks.");
        return false;
    }
    tl.debug("Credential config is enabled.");
    return true;
}
exports.isCredentialConfigEnabled = isCredentialConfigEnabled;
function getNuGetProxyFromEnvironment() {
    let proxyUrl = tl.getVariable("agent.proxyurl");
    let proxyUsername = tl.getVariable("agent.proxyusername");
    let proxyPassword = tl.getVariable("agent.proxypassword");
    if (proxyUrl !== undefined) {
        let proxy = url.parse(proxyUrl);
        if (proxyUsername !== undefined) {
            proxy.auth = proxyUsername;
            if (proxyPassword !== undefined) {
                proxy.auth += `:${proxyPassword}`;
            }
        }
        return url.format(proxy);
    }
    return undefined;
}
exports.getNuGetProxyFromEnvironment = getNuGetProxyFromEnvironment;
function getProxyBypassForUri(registryUri) {
    // check if there are any proxy bypass hosts
    const proxyBypassHosts = JSON.parse(tl.getVariable('Agent.ProxyBypassList') || '[]');
    if (proxyBypassHosts == null || proxyBypassHosts.length == 0) {
        return undefined;
    }
    const uri = url.parse(registryUri);
    if (uri.hostname != null) {
        const bypass = proxyBypassHosts.some(bypassHost => {
            return (new RegExp(bypassHost, 'i').test(uri.href));
        });
        if (bypass) {
            return uri.hostname;
        }
    }
    return undefined;
}
exports.getProxyBypassForUri = getProxyBypassForUri;
function getProxyBypassForConfig(configFile) {
    // check if there are any proxy bypass hosts
    const proxyBypassHosts = JSON.parse(tl.getVariable('Agent.ProxyBypassList') || '[]');
    if (proxyBypassHosts == null || proxyBypassHosts.length == 0) {
        return undefined;
    }
    // get the potential package sources
    let sources = ngutil.getSourcesFromNuGetConfig(configFile);
    // convert to urls
    let sourceUris = sources.reduce(function (result, current) {
        try {
            const uri = url.parse(current.feedUri);
            if (uri.hostname != null) {
                result.push(uri);
            }
        }
        finally {
            return result;
        }
    }, []);
    const bypassDomainSet = new Set();
    proxyBypassHosts.forEach((bypassHost => {
        // if there are no more sources, stop processing regexes
        if (sourceUris == null || sourceUris.length == 0) {
            return;
        }
        let regex = new RegExp(bypassHost, 'i');
        // filter out the sources that match the current regex
        sourceUris = sourceUris.filter(sourceUri => {
            if (regex.test(sourceUri.href)) {
                bypassDomainSet.add(sourceUri.hostname);
                return false;
            }
            return true;
        });
    }));
    // return a comma separated list of the bypass domains
    if (bypassDomainSet.size > 0) {
        const bypassDomainArray = Array.from(bypassDomainSet);
        return bypassDomainArray.join(',');
    }
    return undefined;
}
exports.getProxyBypassForConfig = getProxyBypassForConfig;
function buildCredentialJson(authInfo) {
    if (authInfo && authInfo.externalAuthInfo) {
        let enpointCredentialsJson = {
            endpointCredentials: []
        };
        tl.debug(`Detected external credentials for:`);
        authInfo.externalAuthInfo.forEach((authInfo) => {
            switch (authInfo.authType) {
                case (auth.ExternalAuthType.UsernamePassword):
                    let usernamePasswordAuthInfo = authInfo;
                    enpointCredentialsJson.endpointCredentials.push({
                        endpoint: authInfo.packageSource.feedUri,
                        username: usernamePasswordAuthInfo.username,
                        password: usernamePasswordAuthInfo.password
                    });
                    tl.debug(authInfo.packageSource.feedUri);
                    break;
                case (auth.ExternalAuthType.Token):
                    let tokenAuthInfo = authInfo;
                    enpointCredentialsJson.endpointCredentials.push({
                        endpoint: authInfo.packageSource.feedUri,
                        /* No username provided */
                        password: tokenAuthInfo.token
                    });
                    tl.debug(authInfo.packageSource.feedUri);
                    break;
                case (auth.ExternalAuthType.ApiKey):
                    /* ApiKey is only valid form of credentials for the push command.
                    Only the NuGet Restore task will use the V2 credential provider for handling external credentials.*/
                    tl.debug(authInfo.packageSource.feedUri);
                    tl.debug(`ApiKey is not supported`);
                    break;
                default:
                    break;
            }
        });
        if (enpointCredentialsJson.endpointCredentials.length < 1) {
            tl.debug(`None detected.`);
            return null;
        }
        const externalCredentials = JSON.stringify(enpointCredentialsJson);
        return externalCredentials;
    }
    return null;
}
