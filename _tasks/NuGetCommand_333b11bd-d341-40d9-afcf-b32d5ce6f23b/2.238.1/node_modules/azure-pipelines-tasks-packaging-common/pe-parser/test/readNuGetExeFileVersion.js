"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const fs = require("fs");
const https = require("https");
const path = require("path");
const Q = require("q");
const peReader = require("./..");
const VersionInfoVersion_1 = require("../VersionInfoVersion");
function download(url, downloadPath) {
    return __awaiter(this, void 0, void 0, function* () {
        let file = fs.createWriteStream(downloadPath);
        file.on("error", err => { throw err; });
        let finishPromise = new Promise(function (resolve, reject) {
            file.on("finish", resolve);
        });
        yield new Promise(function (resolve, reject) {
            https.get(url, function (response) {
                if (response.statusCode !== 200) {
                    reject(`Failed to download ${url}: ${response.statusCode} ${response.statusMessage}`);
                    return;
                }
                response.on("end", resolve);
                response.on("error", reject);
                response.pipe(file);
            }).on("error", reject);
        });
        file.end(null, null, file.close);
        yield finishPromise;
    });
}
const tempDir = path.resolve(__dirname, "..", "_temp");
class NuGetVersion {
    constructor(url, version, stringVersion) {
        this.url = url;
        this.version = version;
        this.stringVersion = stringVersion;
    }
    get fileName() {
        return `NuGet${this.version}.exe`;
    }
    get filePath() {
        return path.resolve(tempDir, this.fileName);
    }
}
const nuGetVersions = [
    new NuGetVersion("https://dist.nuget.org/win-x86-commandline/v4.0.0/nuget.exe", new VersionInfoVersion_1.default(4, 0, 0, 2283), "4.0.0.2283"),
    new NuGetVersion("https://dist.nuget.org/win-x86-commandline/v3.5.0-rc1/NuGet.exe", new VersionInfoVersion_1.default(3, 5, 0, 1737), "3.5.0-rtm-1737"),
    new NuGetVersion("https://dist.nuget.org/win-x86-commandline/v3.5.0-beta2/NuGet.exe", new VersionInfoVersion_1.default(3, 5, 0, 1520), "3.5.0-beta2-1520"),
    new NuGetVersion("https://dist.nuget.org/win-x86-commandline/v3.4.4/NuGet.exe", new VersionInfoVersion_1.default(3, 4, 4, 1321), "3.4.4-rtm-1321"),
    new NuGetVersion("https://dist.nuget.org/win-x86-commandline/v3.3.0/nuget.exe", new VersionInfoVersion_1.default(3, 3, 0, 212), "3.3.0"),
    new NuGetVersion("https://dist.nuget.org/win-x86-commandline/v3.2.0/nuget.exe", new VersionInfoVersion_1.default(3, 2, 0, 10516), "3.2.0"),
    new NuGetVersion("https://dist.nuget.org/win-x86-commandline/v2.8.6/nuget.exe", new VersionInfoVersion_1.default(2, 8, 60717, 93), "2.8.6"),
];
function ensureNuGetDownloads() {
    return __awaiter(this, void 0, void 0, function* () {
        if (!fs.existsSync(tempDir)) {
            yield Q.nfcall(fs.mkdir, tempDir);
        }
        for (let i of nuGetVersions) {
            if (!fs.existsSync(i.filePath)) {
                // tslint:disable-next-line
                console.log(`Downloading ${i.url} to ${i.filePath}`);
                yield download(i.url, i.filePath);
            }
        }
    });
}
describe("Can read nuget.exe", function () {
    before(function (done) {
        this.timeout(100000);
        ensureNuGetDownloads().then(() => done()).catch(done);
    });
    for (let i of nuGetVersions) {
        it(`can read version from nuget.exe ${i.version}`, function () {
            return __awaiter(this, void 0, void 0, function* () {
                const versionInfo = yield peReader.getFileVersionInfoAsync(i.filePath);
                assert(versionInfo.fileVersion.equals(i.version), `expected ${i.version}, actual ${versionInfo.fileVersion}`);
                assert.strictEqual(versionInfo.strings.ProductVersion, i.stringVersion);
            });
        });
    }
});
