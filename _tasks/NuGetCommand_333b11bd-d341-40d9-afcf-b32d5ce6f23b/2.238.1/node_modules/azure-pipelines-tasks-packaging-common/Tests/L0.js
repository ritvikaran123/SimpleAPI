"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const npmL0_1 = require("./npm/npmL0");
const nugetL0_1 = require("./nuget/nugetL0");
const nugetToolGetterTests_1 = require("./nuget/nugetToolGetterTests");
const pkgLocationUtils = require("../locationUtilities");
const assert = require("assert");
describe("packaging-common Task Suite", function () {
    describe("nuget common", nugetL0_1.nugetcommon);
    describe("nuget tool getter", nugetToolGetterTests_1.nugettoolgetter);
    describe("npm common", npmL0_1.npmcommon);
});
describe("packaging-common locationUtilities Suite", function () {
    it("retryOnExceptionHelper, succeeds after one retry", () => __awaiter(this, void 0, void 0, function* () {
        let numExecutions = 0;
        let succeedAfterThrowingOnce = () => {
            if (numExecutions == 1) {
                return new Promise((resolve, _) => resolve(true));
            }
            else {
                numExecutions++;
                throw new Error();
            }
        };
        let result = yield pkgLocationUtils.retryOnExceptionHelper(() => succeedAfterThrowingOnce(), 3, 10);
        assert(result == true, "result should have been true");
        assert(numExecutions == 1, "succeedAfterThrowingOnce should have run twice.");
    }));
    it("retryOnExceptionHelper, throws after one retry", () => __awaiter(this, void 0, void 0, function* () {
        let numExecutions = 0;
        let succeedAfterThrowingOnce = () => {
            if (numExecutions == 1) {
                return new Promise((resolve, _) => resolve(true));
            }
            else {
                numExecutions++;
                throw new Error("Error thrown");
            }
        };
        pkgLocationUtils.retryOnExceptionHelper(() => succeedAfterThrowingOnce(), 1, 10)
            .then(() => {
            assert.fail("retryOnExceptionHelper should have failed after no retries, but succeeded");
        })
            .catch(() => {
            assert(numExecutions == 1, "retryOnExceptionHelper should have failed after no retries.");
        });
    }));
    it("retryOnNullOrExceptionHelper, null response, succeeds after one retry", () => __awaiter(this, void 0, void 0, function* () {
        let numExecutions = 0;
        let succeedAfterReturningNullOnce = () => {
            if (numExecutions == 1) {
                return new Promise((resolve, _) => resolve(true));
            }
            else {
                numExecutions++;
                return null;
            }
        };
        let result = yield pkgLocationUtils.retryOnNullOrExceptionHelper(() => succeedAfterReturningNullOnce(), 3, 10);
        assert(result == true, "result should have been true");
        assert(numExecutions == 1, "succeedAfterReturningNullOnce should have run twice.");
    }));
    it("retryOnNullOrExceptionHelper, null response, throws after one retry", () => __awaiter(this, void 0, void 0, function* () {
        let numExecutions = 0;
        let succeedAfterReturningNullOnce = () => {
            if (numExecutions == 1) {
                return new Promise((resolve, _) => resolve(true));
            }
            else {
                numExecutions++;
                return null;
            }
        };
        pkgLocationUtils.retryOnExceptionHelper(() => succeedAfterReturningNullOnce(), 1, 10)
            .then(() => {
            assert.fail("retryOnNullOrExceptionHelper should have failed after no retries, but succeeded");
        })
            .catch(() => {
            assert(numExecutions == 1, "retryOnNullOrExceptionHelper should have failed after no retries.");
        });
    }));
    it("retryOnNullOrExceptionHelper, undefined response, succeeds after one retry", () => __awaiter(this, void 0, void 0, function* () {
        let numExecutions = 0;
        let succeedAfterReturningUndefinedOnce = () => {
            if (numExecutions == 1) {
                return new Promise((resolve, _) => resolve(true));
            }
            else {
                numExecutions++;
                return undefined;
            }
        };
        let result = yield pkgLocationUtils.retryOnNullOrExceptionHelper(() => succeedAfterReturningUndefinedOnce(), 3, 10);
        assert(result == true, "result should have been true");
        assert(numExecutions == 1, "succeedAfterReturningUndefinedOnce should have run twice.");
    }));
    it("retryOnNullOrExceptionHelper, undefined response, throws after one retry", () => __awaiter(this, void 0, void 0, function* () {
        let numExecutions = 0;
        let succeedAfterReturningUndefinedOnce = () => {
            if (numExecutions == 1) {
                return new Promise((resolve, _) => resolve(true));
            }
            else {
                numExecutions++;
                return undefined;
            }
        };
        pkgLocationUtils.retryOnExceptionHelper(() => succeedAfterReturningUndefinedOnce(), 1, 10)
            .then(() => {
            assert.fail("retryOnNullOrExceptionHelper should have failed after no retries, but succeeded");
        })
            .catch(() => {
            assert(numExecutions == 1, "retryOnNullOrExceptionHelper should have failed after no retries.");
        });
    }));
});
